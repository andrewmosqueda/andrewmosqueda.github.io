{
    "version": "https://jsonfeed.org/version/1",
    "title": "Andrew Mosqueda",
    "description": "",
    "home_page_url": "https://andrewmosqueda.github.io",
    "feed_url": "https://andrewmosqueda.github.io/feed.json",
    "user_comment": "",
    "author": {
        "name": "Andrew Mosqueda"
    },
    "items": [
        {
            "id": "https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-3-protection/",
            "url": "https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-3-protection/",
            "title": "Sensorless 6-Step Control for 3-Phase Brushless Motor Tutorial - Part 3 Back EMF Detection",
            "summary": "Introduction This is a continuation of tutorial Potentiometer. In this tutorial, we will determine the Back EMF (BEMF) level that we need to detect. The BEMF detection is the key to determine the optimum commutation speed of the motor. Below are the map of the BEMF&hellip;",
            "content_html": "<h2>Introduction</h2>\n<p>This is a continuation of tutorial <a href=\"https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-2-potentiometer/\" target=\"_blank\" rel=\"noopener noreferrer\">Potentiometer</a>. In this tutorial, we will determine the Back EMF (BEMF) level that we need to detect. The BEMF detection is the key to determine the optimum commutation speed of the motor. Below are the map of the BEMF signals of the X-NUCLEO-IHM07M1 board.</p>\n<table style=\"border-collapse: collapse; width: 119.384%;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 17.8774%;\">Signal Name</td>\n<td style=\"width: 37.6908%;\">Definition</td>\n<td style=\"width: 13.1193%;\">Header Pin</td>\n<td style=\"width: 52.4979%;\">MCU Pin</td>\n</tr>\n<tr>\n<td style=\"width: 17.8774%;\">GPIO_BEMF</td>\n<td style=\"width: 37.6908%;\">\n<p>This pin should be pulled down to</p>\n<p>enable BEMF measurement.</p>\n</td>\n<td style=\"width: 13.1193%;\">C10_1</td>\n<td style=\"width: 52.4979%;\">PC9</td>\n</tr>\n<tr>\n<td style=\"width: 17.8774%;\">BEMF1</td>\n<td style=\"width: 37.6908%;\">Phase 1 Back-EMF signal</td>\n<td style=\"width: 13.1193%;\">C7_37</td>\n<td style=\"width: 52.4979%;\">PC3</td>\n</tr>\n<tr>\n<td style=\"width: 17.8774%;\">BEMF2</td>\n<td style=\"width: 37.6908%;\">Phase 2 Back-EMF signal</td>\n<td style=\"width: 13.1193%;\">C7_34</td>\n<td style=\"width: 52.4979%;\">PB0</td>\n</tr>\n<tr>\n<td style=\"width: 17.8774%;\">BEMF3</td>\n<td style=\"width: 37.6908%;\">Phase 3 Back-EMF signal</td>\n<td style=\"width: 13.1193%;\">C10_15</td>\n<td style=\"width: 52.4979%;\">PA7</td>\n</tr>\n</tbody>\n</table>\n<p>We will use BEMF3 as the BEMF detector because this pin can be connected to the positive input of an internal analog comparator of the MCU. A DAC will be used as negative input of the comparator. The DAC level will be determined using trial and error.</p>\n<h2>Configuration</h2>\n<ol>\n<li>Open the Six_Step project on STM32CubeIDE. This is the project generated on the 2nd tutorial <a href=\"https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-2-potentiometer/\" target=\"_blank\" rel=\"noopener noreferrer\">Potentiometer</a>. </li>\n<li>Open the Six_Step.ioc.</li>\n<li>On the Pinout view, click on PC9 and select GPIO_Output. This pin will be used to enable the BEMF measurement.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/14/PC9_BEMF.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-2xl.jpg 1600w\"  alt=\"\" width=\"146\" height=\"171\"></figure></li>\n<li>Click Analog-&gt;DAC. Enable the OUT1 Configuration.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/14/DAC-Setup.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-2xl.jpg 1600w\"  alt=\"\" width=\"462\" height=\"265\"></figure></li>\n<li>On the Pinout view. Click PA4 and select COMP2_INM.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/14/PA4.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-2xl.jpg 1600w\"  alt=\"\" width=\"97\" height=\"224\"></figure></li>\n<li>On the Pinout view. Click PA7 and select COMP2_INP. <br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/14/PA7_COMP2_INP-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-2xl.jpg 1600w\"  alt=\"\" width=\"149\" height=\"230\"></figure></li>\n<li>Click Analog-&gt;COMP2. Select INP as positive input. Select INM as negative input. In the Parameter Settings, select Rising Edge as the Interrupt Trigger Mode.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/14/Comparator-setup-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-2xl.jpg 1600w\"  alt=\"\" width=\"649\" height=\"436\"></figure></li>\n<li>On the Pinout view, click PB2 and select GPIO_Output. This pin is connected to a LED. We will turn on the LED everytime the comparator 2 interrupt is triggered and turn off everytime the TIMER 16 interrupt is triggered.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/14/PB2_LED.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-2xl.jpg 1600w\"  alt=\"\" width=\"136\" height=\"179\"></figure></li>\n<li>Ctrl+s to save the configuration and go to main.c</li>\n</ol>\n<h2>Coding</h2>\n<ol>\n<li>In main.c <code>/* Initialize all configured peripherals */</code>. Make sure that the <code>MX_DMA_Init();</code> is written first before <code>MX_ADC1_Init();</code>, else the DMA will not initialize properly.</li>\n<li>After <code>#define ADC_BUF_LEN 1</code>, add <code>#define BEMF_LIMIT 1 // Volt(s)</code></li>\n<li>Below <code>#define BEMF_LIMIT 1 // Volt(s)</code>, add <code>#define DAC1_DHR12L1 ((uint16_t)(65535*BEMF_LIMIT/3.3))</code></li>\n<li>Before <code>/* USER CODE END 2 */</code> add the following code: <br><code>//BEMF DAC for comparator</code><br><code>  HAL_DAC_Start(&amp;hdac, DAC_CHANNEL_1);</code><br><code>  DAC1-&gt;DHR12L1 = DAC1_DHR12L1;</code><br><br><code>  //BEMF Comparator</code><br><code>  HAL_COMP_Start_IT(&amp;hcomp2);</code></li>\n<li>Next we add the comparator interrupt handler, add the following code before  <code>/* USER CODE END 4 */</code> line : <br><code>void HAL_COMP_TriggerCallback(COMP_HandleTypeDef *hcomp)</code><br><code>{</code><br><code>    if (hcomp == &amp;hcomp2) HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, GPIO_PIN_SET); // Turn on LED</code><br><code> }</code></li>\n<li>Then reset the LED on the TIMER16 interrupt. Add <code>HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_2); // Turn off LED</code> after the <code>TIM16-&gt;CCR1 = (adc_buf[0] * TIM16_PERIOD) &gt;&gt; 12 ;</code> line.</li>\n</ol>\n<h2>Determine Optimum BEMF </h2>\n<ol>\n<li>On the X-NUCLEO board. Set JP1 and JP2 to open position. Set JP5 and JP6 to 1Sh position.</li>\n<li>Connect the 12V DC power supply to J1 and the motor to J2.</li>\n<li>Connect an oscilloscope probe to C10_15. C10_15 is the BEMF3 signal.</li>\n<li>Connect an oscilloscope probe to C10_22. C10_22 is the LED signal.</li>\n<li>Click Run-&gt;Run menu to compile and load the program to the MCU. The orange waveform below is the BEMF of PH3. The purple waveform is the LED signal which is turned on every time BEMF rises and then turned off by TIMER16 which has a frequency of about 10kHz.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/14/BEMF-vs-LED.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-2xl.jpg 1600w\"  alt=\"\" width=\"752\" height=\"451\"></figure></li>\n<li>We can see that the peak voltage of the BEMF at zero torque position is 1.268V.</li>\n<li>Now rotate counter clockwise the motor until you feel the maximum torque. It is important that the potentiometer is set to minimum position while doing this to easily rotate the motor. Below is the waveform at maximum torque that I got.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/14/BEMF-vs-LED-Max-Torque.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-2xl.jpg 1600w\"  alt=\"\" width=\"709\" height=\"452\"></figure></li>\n<li>We can see that the peak voltage of the BEMF at maximum torque position is 1.494V.</li>\n<li>Therefore to balance torque and speed, we will use 1.381V as the BEMF level for the comparator. </li>\n<li>Change <code>#define BEMF_LIMIT 1 // Volt(s)</code> to <code>#define BEMF_LIMIT 1.381 // Volt(s)</code> Click Run-&gt;Run. We should observe now that the LED is not turning on at zero torque: <br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/14/BEMF-vs-LED-DAC-26250-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-2xl.jpg 1600w\"  alt=\"\" width=\"712\" height=\"448\"></figure>But if we rotate counter clockwise the motor so that the peak voltage of the BEMF reaches 1.381V we will observe the LED begins to toggle.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/14/BEMF-vs-LED-Peak_1.381V.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-2xl.jpg 1600w\"  alt=\"\" width=\"712\" height=\"460\"></figure></li>\n</ol>\n<p>Below is the video demo of the BEMF detection. Observe that the LED shines as I rotate the motor.</p>\n<figure class=\"post__video\"><iframe loading=\"lazy\" width=\"560\" height=\"314\" src=\"https://www.youtube.com/embed/O2ePFm1O0r0\" allowfullscreen=\"allowfullscreen\" data-mce-fragment=\"1\"></iframe></figure>",
            "author": {
                "name": "Andrew Mosqueda"
            },
            "tags": [
            ],
            "date_published": "2022-02-02T11:30:09+08:00",
            "date_modified": "2022-02-03T00:09:40+08:00"
        },
        {
            "id": "https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-2-potentiometer/",
            "url": "https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-2-potentiometer/",
            "title": "Sensorless 6-step Control for 3-Phase Brushless Motor Tutorial - Part 2 Potentiometer",
            "summary": "INTRODUCTION In this tutorial, we will configure and add code to utilize the potentiometer of the X-NUCLEO-IHM07M1 board in adjusting the current limit of the stator PWM. Below table summarizes the map of the potentiometer signal vs board connector pin and MCU pin. We will&hellip;",
            "content_html": "<h2>INTRODUCTION</h2>\n<p>In this tutorial, we will configure and add code to utilize the potentiometer of the X-NUCLEO-IHM07M1 board in adjusting the current limit of the stator PWM. Below table summarizes the map of the potentiometer signal vs board connector pin and MCU pin. We will set PB1 of the MCU as an analog input. We will configure an ADC and DMA to automatically store the voltage level on PB1 to a memory. </p>\n<table style=\"border-collapse: collapse; width: 100%;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 33.3333%;\">Signal Name</td>\n<td style=\"width: 33.3333%;\">Board Connector</td>\n<td style=\"width: 33.3333%;\">MCU Pin</td>\n</tr>\n<tr>\n<td style=\"width: 33.3333%;\">SPEED</td>\n<td style=\"width: 33.3333%;\">C10_24</td>\n<td style=\"width: 33.3333%;\">PB1</td>\n</tr>\n</tbody>\n</table>\n<p>The TIMER16 that is used for current reference PWM will be configured to have its interrupt enabled. The interrupt will be used to change the value of the current reference based from the value stored in the memory that is being updated by the DMA.</p>\n<h2>CONFIGURATION</h2>\n<ol>\n<li>Open the Six_Step project on STM32CubeIDE. This is the project generated on the first tutorial <a href=\"https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-1/\" target=\"_blank\" rel=\"noopener noreferrer\">Stator PWM</a>.</li>\n<li>Open the Six_Step.ioc.</li>\n<li>On the Pinout view, click on PB1 and select ADC1_IN12.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/13/PB1.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/13/responsive/PB1-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/13/responsive/PB1-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/13/responsive/PB1-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/13/responsive/PB1-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/13/responsive/PB1-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/13/responsive/PB1-2xl.jpg 1600w\"  alt=\"\" width=\"348\" height=\"273\"></figure></li>\n<li>Click Analog-&gt;ADC1 and select IN12 Single-ended for IN12.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/13/ADC-Mode-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Mode-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Mode-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Mode-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Mode-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Mode-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Mode-2-2xl.jpg 1600w\"  alt=\"\" width=\"450\" height=\"303\"></figure></li>\n<li>Click System Core-&gt;DMA. Configure as illustrated below.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/13/DMA.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/13/responsive/DMA-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/13/responsive/DMA-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/13/responsive/DMA-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/13/responsive/DMA-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/13/responsive/DMA-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/13/responsive/DMA-2xl.jpg 1600w\"  alt=\"\" width=\"488\" height=\"227\"></figure></li>\n<li>Go back to the ADC1. Configure as illustrated below.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/13/ADC-Configuration.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Configuration-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Configuration-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Configuration-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Configuration-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Configuration-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/13/responsive/ADC-Configuration-2xl.jpg 1600w\"  alt=\"\" width=\"356\" height=\"408\"></figure></li>\n<li>Click System Core-&gt;NVIC. Enable TIM1 update and TIM16 interrupts.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/13/TIM16-interrupt.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/13/responsive/TIM16-interrupt-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/13/responsive/TIM16-interrupt-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/13/responsive/TIM16-interrupt-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/13/responsive/TIM16-interrupt-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/13/responsive/TIM16-interrupt-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/13/responsive/TIM16-interrupt-2xl.jpg 1600w\"  alt=\"\" width=\"387\" height=\"329\"></figure></li>\n<li>Ctrl+s to save the configuration and go back to main.c</li>\n</ol>\n<h2>CODING</h2>\n<ol>\n<li>In main.c <code>/* Initialize all configured peripherals */</code>, check if <code>MX_DMA_Init();</code> is written first before <code>MX_ADC1_Init();</code>. The DMA must be initialized first before the ADC, else the DMA will not work.</li>\n<li>Add <code>#define ADC_BUF_LEN 1</code> after<code> #define R44 0.33</code> line.</li>\n<li>Add <code>uint16_t adc_buf[ADC_BUF_LEN];</code> after <code>/* USER CODE BEGIN PV */</code> line.</li>\n<li>After <code>TIM16-&gt;CCR1 = TIM16_DUTY;</code> line, add the following: <br><code>//ADC for current reference limit</code><br><code>   HAL_ADC_Start_DMA(&amp;hadc1, (uint32_t*) adc_buf, ADC_BUF_LEN);</code></li>\n<li>Rename <code>HAL_TIM_Base_Start(&amp;htim16);</code>  to <code>HAL_TIM_Base_Start_<span style=\"text-decoration: underline;\"><strong>IT</strong></span>(&amp;htim16);</code></li>\n<li>Rename <code>HAL_TIM_PWM_Start(&amp;htim16, TIM_CHANNEL_1);</code> to <code>HAL_TIM_PWM_Start_<span style=\"text-decoration: underline;\"><strong>IT</strong></span>(&amp;htim16, TIM_CHANNEL_1);</code></li>\n<li>After <code>/* USER CODE BEGIN 4 */</code> add the following code: <br><code>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</code><br><code>{</code><br><code> if(htim==&amp;htim16) TIM16-&gt;CCR1 = (adc_buf[0] * TIM16_PERIOD) &gt;&gt; 12 ;</code><br><code>}</code></li>\n</ol>\n<h2>TEST</h2>\n<ol>\n<li>On the X-NUCLEO board. Set JP1 and JP2 to open position. Set JP5 and JP6 to 1Sh position.</li>\n<li>Connect the 12V DC power supply to J1 and the motor to J2.</li>\n<li>Connect an oscilloscope probe to J16. J16 is the negative input reference of the built-in comparator of the driver IC.</li>\n<li>Connect an oscilloscope probe to C7_36. C7_36 is the stator current feedback signal.</li>\n<li>Connect an oscilloscope probe to C10_12. C10_12 is the output of the driver IC comparator.</li>\n<li>Make sure the potentiometer is set to minimum position as shown below:<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/13/Pot_minjpg.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_minjpg-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_minjpg-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_minjpg-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_minjpg-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_minjpg-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_minjpg-2xl.jpg 1600w\"  alt=\"\" width=\"689\" height=\"499\"></figure>Caution: If potentiometer is set high, the driver IC may get too hot.</li>\n<li>Click Run-&gt;Run menu to compile and load the program to the MCU. We should get a similar waveform on the oscilloscope below. The orange waveform is the current reference. The purple waveform is the current feedback. The blue waveform in the bottom is the output of the comparator.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/13/Pot_0.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_0-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_0-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_0-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_0-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_0-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_0-2xl.jpg 1600w\"  alt=\"\" width=\"709\" height=\"432\"></figure></li>\n<li>Rotate the potentiometer by about 45°. Observe that the peak of reference current and peak current increases as shown below. We can confirm now that the current limit of the stator can be adjusted by the potentiometer.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/13/Pot_45.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_45-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_45-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_45-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_45-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_45-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/13/responsive/Pot_45-2xl.jpg 1600w\"  alt=\"\" width=\"716\" height=\"425\"></figure></li>\n</ol>\n<p> </p>",
            "author": {
                "name": "Andrew Mosqueda"
            },
            "tags": [
            ],
            "date_published": "2022-02-01T15:56:14+08:00",
            "date_modified": "2022-02-02T11:06:51+08:00"
        },
        {
            "id": "https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-1/",
            "url": "https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-1/",
            "title": "Sensorless 6-Step Control for 3-Phase Brushless Motor Tutorial - Part 1 Stator PWM",
            "summary": "Introduction This tutorial is done with NUCLEO-F302R8 MCU board with X-NUCLEO-IHM07M1 expansion board and BR2804-1700KV-1 3-phase motor. The IDE used is STM32CubeIDE 1.8.0. The X-NUCLEO-IHM07M1 expansion board uses L6230 DMOS driver IC. The EN1, IN1, EN2, IN2, EN3 and IN3 pins of the IC are&hellip;",
            "content_html": "<h2>Introduction</h2>\n<p>This tutorial is done with NUCLEO-F302R8 MCU board with X-NUCLEO-IHM07M1 expansion board and BR2804-1700KV-1 3-phase motor. The IDE used is STM32CubeIDE 1.8.0.</p>\n<h2>Create Project</h2>\n<ol>\n<li>Open STM32CubeIDE.</li>\n<li>File-&gt;New-&gt;STM32 Project.</li>\n<li>After \"STM32 Project\" dialog is loaded. Click on \"Board Selector\" Tab. Type \"NUCLEO-F302R8\" as the part number. Click the board listed on the left then click Next button.<br><figure class=\"post__image align-center\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12//New-Project.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12//responsive/New-Project-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12//responsive/New-Project-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12//responsive/New-Project-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12//responsive/New-Project-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12//responsive/New-Project-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12//responsive/New-Project-2xl.jpg 1600w\"  alt=\"New Project\" width=\"417\" height=\"325\"></figure></li>\n<li>Name the project \"Six_Step\" then click Finish button.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12//Project-Name.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12//responsive/Project-Name-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12//responsive/Project-Name-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12//responsive/Project-Name-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12//responsive/Project-Name-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12//responsive/Project-Name-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12//responsive/Project-Name-2xl.jpg 1600w\"  alt=\"Project Name\" width=\"337\" height=\"366\"></figure></li>\n<li>If \"Board Project Options\" dialog box is displayed. Click \"Yes\" to initialize all peripherals with their default Mode.</li>\n</ol>\n<figure class=\"post__image align-center\">At this point, the Pinout &amp; Configuration window of the project should be displayed like below.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12//Pinout-and-Config-Window.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12//responsive/Pinout-and-Config-Window-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12//responsive/Pinout-and-Config-Window-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12//responsive/Pinout-and-Config-Window-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12//responsive/Pinout-and-Config-Window-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12//responsive/Pinout-and-Config-Window-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12//responsive/Pinout-and-Config-Window-2xl.jpg 1600w\"  alt=\"Pinout and Configuration window\" width=\"882\" height=\"515\"></figure>\n<h2>Configure the Stator PWM</h2>\n<p>The X-NUCLEO-IHM07M1 expansion board uses L6230 DMOS driver IC. The EN1, IN1, EN2, IN2, EN3 and IN3 pins of the IC are used to control the MOSFETS of the IC. Below table is the definition and map of these pins to the board header pins and MCU pins.</p>\n<table style=\"border-collapse: collapse; width: 99.4299%; height: 450px;\" border=\"1\">\n<tbody>\n<tr style=\"height: 48px;\">\n<td style=\"width: 16.6667%; height: 48px;\">L6230 Pin</td>\n<td style=\"width: 20.7978%; height: 48px;\">Definition</td>\n<td style=\"width: 29.2022%; height: 48px;\">Board Header Pin</td>\n<td style=\"width: 33.3333%; height: 48px;\">MCU Pin</td>\n</tr>\n<tr style=\"height: 48px;\">\n<td style=\"width: 16.6667%; height: 48px;\">EN1</td>\n<td style=\"width: 20.7978%; height: 48px;\">PH1 Enable</td>\n<td style=\"width: 29.2022%; height: 48px;\">C7_1</td>\n<td style=\"width: 33.3333%; height: 48px;\">PC10</td>\n</tr>\n<tr style=\"height: 48px;\">\n<td style=\"width: 16.6667%; height: 48px;\">IN1</td>\n<td style=\"width: 20.7978%; height: 48px;\">PH1 Hi/Low</td>\n<td style=\"width: 29.2022%; height: 48px;\">C10_23</td>\n<td style=\"width: 33.3333%; height: 48px;\">PA8</td>\n</tr>\n<tr style=\"height: 48px;\">\n<td style=\"width: 16.6667%; height: 48px;\">EN2</td>\n<td style=\"width: 20.7978%; height: 48px;\">PH2 Enable</td>\n<td style=\"width: 29.2022%; height: 48px;\">C7_2</td>\n<td style=\"width: 33.3333%; height: 48px;\">PC11</td>\n</tr>\n<tr style=\"height: 48px;\">\n<td style=\"width: 16.6667%; height: 48px;\">IN2</td>\n<td style=\"width: 20.7978%; height: 48px;\">PH2 Hi/Low</td>\n<td style=\"width: 29.2022%; height: 48px;\">C10_21</td>\n<td style=\"width: 33.3333%; height: 48px;\">PA9</td>\n</tr>\n<tr style=\"height: 48px;\">\n<td style=\"width: 16.6667%; height: 48px;\">EN3</td>\n<td style=\"width: 20.7978%; height: 48px;\">PH3 Enable</td>\n<td style=\"width: 29.2022%; height: 48px;\">C7_3</td>\n<td style=\"width: 33.3333%; height: 48px;\">PC12</td>\n</tr>\n<tr style=\"height: 48px;\">\n<td style=\"width: 16.6667%; height: 48px;\">IN3</td>\n<td style=\"width: 20.7978%; height: 48px;\">PH3 Hi/Low</td>\n<td style=\"width: 29.2022%; height: 48px;\">C10_33</td>\n<td style=\"width: 33.3333%; height: 48px;\">PA10</td>\n</tr>\n</tbody>\n</table>\n<p>We will connect the MCU Pins PA8, PA9 and PA10 defined above as PWM output of the TIMER1.</p>\n<ol>\n<li>On the pinout window, click PA8 and select TIM1_CH1.<br><figure class=\"post__image align-center\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/PA8-TIM1_CH1-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/PA8-TIM1_CH1-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/PA8-TIM1_CH1-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/PA8-TIM1_CH1-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/PA8-TIM1_CH1-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/PA8-TIM1_CH1-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/PA8-TIM1_CH1-2-2xl.jpg 1600w\"  alt=\"\" width=\"150\" height=\"263\"></figure></li>\n<li>Do the same thing to PA9 (TIM1_CH2) and PA10 (TIM1_CH3). The pinout setting should look like below.<br><figure class=\"post__image align-center\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/TIM1-pinout.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout-2xl.jpg 1600w\"  alt=\"\" width=\"345\" height=\"285\"></figure></li>\n<li>Click Timers-&gt;TIM1 and configure the channels as shown below. Channel 4 will be used later in an interrupt.<br><figure class=\"post__image align-center\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/TIM1-pwm-channel-config.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pwm-channel-config-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pwm-channel-config-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pwm-channel-config-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pwm-channel-config-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pwm-channel-config-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pwm-channel-config-2xl.jpg 1600w\"  alt=\"\" width=\"358\" height=\"239\"></figure><br>After the configuration, the PA8, PA9 and PA10 pins should turn green as shown below.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/TIM1-pinout2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM1-pinout2-2xl.jpg 1600w\"  alt=\"\" width=\"396\" height=\"333\"></figure></li>\n</ol>\n<p>The MCU pins PC10, PC11 and PC12 that will be used to enable each phase of the L6230 DMOS driver IC need not be controlled by PWM. For each pin, set it as GPIO_Output.</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/PC10-PC11-PC12.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/PC10-PC11-PC12-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/PC10-PC11-PC12-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/PC10-PC11-PC12-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/PC10-PC11-PC12-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/PC10-PC11-PC12-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/PC10-PC11-PC12-2xl.jpg 1600w\"  alt=\"\" width=\"176\" height=\"282\"></figure>\n<h2>Cycle by Cycle Duty Control</h2>\n<p>We will control the duty cycle of the Stator PWM by utilizing the current on the stator. The L6230 DMOS driver IC has a built-in analog comparator that we can utilize to clear the output of the Stator PWM for every Stator PWM cycle. Below table is the definition of the comparator pins and map of these pins to the board header pins and MCU pins.</p>\n<table style=\"border-collapse: collapse; width: 100%;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 20%;\">L6230 Pin</td>\n<td style=\"width: 20%;\">Definition</td>\n<td style=\"width: 20%;\">Board Header Pin</td>\n<td style=\"width: 20%;\">MCU Pin</td>\n</tr>\n<tr>\n<td style=\"width: 20%;\">CP+</td>\n<td style=\"width: 20%;\">Stator Current Feedback</td>\n<td style=\"width: 20%;\">C7_36</td>\n<td style=\"width: 20%;\">PC1</td>\n</tr>\n<tr>\n<td style=\"width: 20%;\">CP- (Filtered)</td>\n<td style=\"width: 20%;\">Current Reference</td>\n<td style=\"width: 20%;\">\n<p>J16 Ring (Filtered)</p>\n<p>C10_27 (PWM)</p>\n</td>\n<td style=\"width: 20%;\">PB4 (Ref PWM Output)</td>\n</tr>\n<tr>\n<td style=\"width: 20%;\">CPOUT</td>\n<td style=\"width: 20%;\">Comparator Output</td>\n<td style=\"width: 20%;\">C10_12</td>\n<td style=\"width: 20%;\">PA12</td>\n</tr>\n</tbody>\n</table>\n<p>We'll use PA12 pin as input to the TIMER1 as clear pin so everytime the L6230 DMOS driver IC CPOUT turns high, the output of the PWM is cleared or reset.</p>\n<ol>\n<li>On the pinout view, click on PA12 pin and select TIM1_ETR. Then on the Mode window, Select ETR IO as Clearing Source. <figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/Timer-ETR.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/Timer-ETR-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Timer-ETR-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Timer-ETR-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Timer-ETR-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Timer-ETR-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Timer-ETR-2xl.jpg 1600w\"  alt=\"\" width=\"679\" height=\"428\"></figure></li>\n<li>On the Configuration, Enable Clear Channel 1, Clear Channel 2 and Clear Channel 3. <figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/Enable-Channel-ETR.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/Enable-Channel-ETR-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Enable-Channel-ETR-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Enable-Channel-ETR-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Enable-Channel-ETR-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Enable-Channel-ETR-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Enable-Channel-ETR-2xl.jpg 1600w\"  alt=\"\" width=\"427\" height=\"327\"></figure></li>\n</ol>\n<p> </p>\n<p>Next, we'll set the MCU pin PB4 as reference PWM to the comparator of the L6230 DMOS driver IC.</p>\n<ol>\n<li>On the pinout view, click PB4 and select TIM16_CH1.</li>\n<li>Click TIM16. Click Activated and select \"PWM Generation CH1\" as Channel1.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/TIM16.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/TIM16-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM16-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM16-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM16-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM16-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/TIM16-2xl.jpg 1600w\"  alt=\"\" width=\"405\" height=\"256\"></figure></li>\n</ol>\n<h2>CODING</h2>\n<p>Save the configuration to generate all the initialization code.</p>\n<ol>\n<li>Ctrl+s to save. Wait until main.c file is generated and displayed.</li>\n<li>Insert the following definition codes after the /* USER CODE BEGIN PD */ line: <br><code>#define STATOR_PWM_FREQ 50E+3 // Hz</code><br><code>#define CURRENT_IREF_LIMIT 0 // Ampere</code><br><code>#define CURRENT_REF_PWM_FREQ 10E+3 // Hz</code><br><code>#define R44 0.33 // Ω - sense resistor</code><br><br><code>#define TIM1_PERIOD ((uint16_t)(64E+6/STATOR_PWM_FREQ - 1)) // calc good only if prescaler is 0</code><br><code>#define TIM1_DEFAULT_DUTY ((uint16_t)(TIM1_PERIOD/2)) // limit stator duty to 0.5</code><br><code>#define TIM16_PERIOD ((uint16_t)(64E+6/CURRENT_REF_PWM_FREQ - 1)) // calc good only if prescaler is 0</code><br><code>#define CURRENT_VREF_LIMIT (CURRENT_IREF_LIMIT*R44) // volts</code><br><code>#define TIM16_DUTY (TIM16_PERIOD*CURRENT_VREF_LIMIT/3.3) // current reference duty cycle</code><br><br><code>#define PH1_HIGH TIM1-&gt;CCR1 = TIM1_DEFAULT_DUTY; HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10, GPIO_PIN_SET);</code><br><code>#define PH1_LOW TIM1-&gt;CCR1 = 0; HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10, GPIO_PIN_SET);</code><br><code>#define PH1_OFF HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10, GPIO_PIN_RESET);</code><br><br><code>#define PH2_HIGH TIM1-&gt;CCR2 = TIM1_DEFAULT_DUTY; HAL_GPIO_WritePin(GPIOC, GPIO_PIN_11, GPIO_PIN_SET);</code><br><code>#define PH2_LOW TIM1-&gt;CCR2 = 0; HAL_GPIO_WritePin(GPIOC, GPIO_PIN_11, GPIO_PIN_SET);</code><br><code>#define PH2_OFF HAL_GPIO_WritePin(GPIOC, GPIO_PIN_11, GPIO_PIN_RESET);</code><br><br><code>#define PH3_HIGH TIM1-&gt;CCR2 = TIM1_DEFAULT_DUTY; HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_SET);</code><br><code>#define PH3_LOW TIM1-&gt;CCR2 = 0; HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_SET);</code><br><code>#define PH3_OFF HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_RESET);</code></li>\n<li>Insert the following code after the /* USER CODE BEGIN 2 */ line: <br><code>//TIMER 1 - Stator PWM</code><br><code>  HAL_TIM_Base_Start(&amp;htim1);</code><br><code>  HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_1);</code><br><code>  HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_2);</code><br><code>  HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_3);</code><br><code>  HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_4);</code><br><code>  TIM1-&gt;ARR = TIM1_PERIOD; </code><br><code>  PH1_HIGH PH2_LOW PH3_OFF</code><br><code>  </code><br><code>  //TIMER 16 - Current Reference PWM</code><br><code>  HAL_TIM_Base_Start(&amp;htim16);</code><br><code>  HAL_TIM_PWM_Start(&amp;htim16, TIM_CHANNEL_1);</code><br><code>  TIM16-&gt;ARR = TIM16_PERIOD; </code><br><code>  TIM16-&gt;CCR1 = TIM16_DUTY; </code></li>\n</ol>\n<h2>TEST</h2>\n<ol>\n<li>On the X-NUCLEO board. Set JP1 and JP2 to open position. Set JP5 and JP6 to 1Sh position.</li>\n<li>Connect the 12V DC power supply to J1 and the motor to J2.</li>\n<li>Connect an oscilloscope probe to C10_23 of the X-NUCLEO board. This probe is used to monitor the PWM signal applied to the driver IC.</li>\n<li>Connect an oscilloscope probe to C7_36 of the X-NUCLEO board. This probe is used to monitor the current feedback voltage that is fed to the built-in comparator of the L6230 DMOS driver IC.</li>\n<li>Click Run-&gt;Run menu to compile and load the program to the MCU. We should get a similar waveform on the oscilloscope below. The orange waveform is the PWM applied to the driver IC while the blue waveform is the current feedback.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/Oscilloscope-PWM-PH1-vs-Current-Reference.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-PWM-PH1-vs-Current-Reference-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-PWM-PH1-vs-Current-Reference-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-PWM-PH1-vs-Current-Reference-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-PWM-PH1-vs-Current-Reference-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-PWM-PH1-vs-Current-Reference-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-PWM-PH1-vs-Current-Reference-2xl.jpg 1600w\"  alt=\"\" width=\"749\" height=\"457\"></figure></li>\n<li>Transfer the probe from C10_23 to J16. J16 is the negative input reference of the built-in comparator of the driver IC. Add another probe to C10_12. C10_12 is the comparator output. We should get a similar waveform below. The orange waveform is now the current reference that limits the current to rise above it. The blue waveform is the comparator output. There is some delay on the turn off of the PWM but at least we have some degree on the control of the current limit.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/Oscilloscope-Current-vs-reference-vs-comparator-output.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output-2xl.jpg 1600w\"  alt=\"\" width=\"757\" height=\"456\"></figure></li>\n<li>Next, we set the current limit from 1A from 0A in the code to confirm that we can control the current limit. In line 36, change the code to #define CURRENT_IREF_LIMIT <strong>0</strong>. Caution: Setting this value too high may turn the IC too hot.</li>\n<li>Click Run-&gt;Run again in the menu to compile and load the program to the MCU. After loading the program, notice that the current reference is now 0V and the peak voltage of the current feedback is reduced to 893.879mV. We can now confirm that we have a cycle-by-cycle control of the Stator PWM.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/12/Oscilloscope-Current-vs-reference-vs-comparator-output2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/12/responsive/Oscilloscope-Current-vs-reference-vs-comparator-output2-2xl.jpg 1600w\"  alt=\"\" width=\"758\" height=\"457\"></figure></li>\n</ol>",
            "author": {
                "name": "Andrew Mosqueda"
            },
            "tags": [
            ],
            "date_published": "2022-02-01T09:18:01+08:00",
            "date_modified": "2022-02-02T09:57:44+08:00"
        },
        {
            "id": "https://andrewmosqueda.github.io/hysteretic-current-mode-buck-converter-for-dspic33/",
            "url": "https://andrewmosqueda.github.io/hysteretic-current-mode-buck-converter-for-dspic33/",
            "title": "Hysteretic Current Mode Buck Converter with dsPIC33",
            "summary": "INTRODUCTION In this article, a hysteretic current control for a 5V to 3.3V buck converter will be implemented in the DM330028 dsPIC33CH Curiosity Development Board. The buck inductor current in a hysteretic current mode flows in a critical conduction so the controller must immediately turn&hellip;",
            "content_html": "<h2>INTRODUCTION</h2>\n<figure class=\"post__image\">In this article, a hysteretic current control for a 5V to 3.3V buck converter will be implemented in the DM330028 dsPIC33CH Curiosity Development Board. The buck inductor current in a hysteretic current mode flows in a critical conduction so the controller must immediately turn on the MOSFET upon detecting the inductor current has returned to zero. When the MOSFET is turned on, the controller must immediately turn off the MOSFET when the target peak current is reached. The target peak current is calculated by a PID algorithm. Below is the buck/boost circuit of the DM330028 board.  There is no direct current sense for the inductor L1 but the high side current sense (R59/R74) resistors can be utilized to measure the rising inductor current when Q6 is on and the low side (R93/R92/R63) current sense resistors can be utilized to measure the decreasing inductor current when Q6 is off.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/power-circuit.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/power-circuit-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/power-circuit-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/power-circuit-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/power-circuit-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/power-circuit-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/power-circuit-2xl.jpg 1600w\"  alt=\"dsPIC33CH Curiosity Development Board Buck/Boost Converter\" width=\"966\" height=\"452\"></figure>\n<figure class=\"post__image\">The inputs for the close loop system are the high side current (ISENSEH_BIASED), the low side current (RD14_ISENSEL pin) and the output voltage (Vout). Below is the circuit on the DM330028 board that converts the high side current sense voltage into a level that is within the range of the dsPIC33 input (RA3_ISENSEH pin). The signal on RA3_ISENSEH will be fed to the + input of a built analog comparator of the dsPIC33CH IC. The - input of the comparator is a DAC that will be fed by a calculated value from a PID algorithm. <br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/high-side-current-level-shifter.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/high-side-current-level-shifter-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/high-side-current-level-shifter-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/high-side-current-level-shifter-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/high-side-current-level-shifter-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/high-side-current-level-shifter-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/high-side-current-level-shifter-2xl.jpg 1600w\"  alt=\"High Side Current Sense Circuit\" width=\"556\" height=\"338\"></figure>\n<figure class=\"post__image\">The PID algorithm is based on the sensed voltage from the Vout sense. Below is the output voltage sense circuit. The sensed voltage  is RC1_VOUTFB. RC1_VOUTFB will be fed to an ADC and then processed in the PID algorithm.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/output-voltage-feedback-sense.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/output-voltage-feedback-sense-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/output-voltage-feedback-sense-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/output-voltage-feedback-sense-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/output-voltage-feedback-sense-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/output-voltage-feedback-sense-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/output-voltage-feedback-sense-2xl.jpg 1600w\"  alt=\"voltage feedback sense circuit\" width=\"536\" height=\"298\"></figure>\n<p>The third input (RD14_ISENSEL) to the control loop has a negative voltage level when MOSFET Q6 is off and inductor L1 is conducting. This negative level voltage is fed to the -input of a programmable gain amplifier to have a positive output value. The DS50002762A document recommends x8 as the gain setting for this signal. The output of the programmable gain amplifier is then fed to another comparator to detect that the current on the inductor has return to zero.</p>\n<p>The first comparator and second comparator outputs are then fed to a built in SR logic circuit as S and R inputs respectively. The output of the SR logic then serves as the drive for MOSFET Q6. For more details or insight on the hysteretic operation, you can check my previous article <a href=\"https://andrewmosqueda.github.io/hysteretic-current-mode-buck-converter-for-dspic33/\" target=\"_blank\" rel=\"noopener noreferrer\">LTspice - Hysteretic Current Mode Buck Converter.</a> </p>\n<h2>MASTER CORE GENERATION</h2>\n<p>The master core here is only used to enable the slave core. All close loop operation will be done on the slave core.</p>\n<ol>\n<li>Run MPLAB X IDE (I'm using version v5.50 at the time of this writing). Connect J20 of the DM330028 Curiosity Development Board to your PC so that the MPLAB application detects what board is connected.</li>\n<li>After opening MPLAB, close any projects that are open on the left pane.</li>\n<li>Ctrl+Shift+N to open the new project dialog box. Select Standalone Project then Click Next.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/master-new-project.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/master-new-project-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-new-project-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-new-project-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-new-project-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-new-project-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-new-project-2xl.jpg 1600w\"  alt=\"MPLAB Create Project\" width=\"902\" height=\"629\"></figure></li>\n<li>In the Select Device dialog, select \"16-bit DSCs (dsPIC33)\" as the Family, \"dsPIC33CH128MP508\" as the Device and \"Starter Kits (PKOB)-SN:BUR182571251\" as the Tool. Note, there is a DM330028-2 version of the Curiosity board so the device and tool will be different. Please refer to its user guide or check the actual part number of the dsPIC IC that is mounted on the board.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/MPLAB-select-device.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB-select-device-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB-select-device-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB-select-device-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB-select-device-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB-select-device-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB-select-device-2xl.jpg 1600w\"  alt=\"MPLAB new project - select device\" width=\"902\" height=\"627\"></figure></li>\n<li>In the next dialog, select Compiler XC16 (v1.70) then click next. You may have a newer version installed.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/select-compiler.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/select-compiler-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/select-compiler-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/select-compiler-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/select-compiler-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/select-compiler-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/select-compiler-2xl.jpg 1600w\"  alt=\"MPLAB select compiler\" width=\"911\" height=\"632\"></figure></li>\n<li>Name the project as \"master\". I save it to folder \"hysteretic\". Click Finish.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/project-name-and-folder.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/project-name-and-folder-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/project-name-and-folder-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/project-name-and-folder-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/project-name-and-folder-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/project-name-and-folder-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/project-name-and-folder-2xl.jpg 1600w\"  alt=\"MPLAB Select Project Name and Folder\" width=\"955\" height=\"633\"></figure></li>\n</ol>\n<h2>SLAVE CORE GENERATION</h2>\n<ol>\n<li>Ctrl+Shift+N to open again the new project dialog box. Select Standalone Project then click Next.</li>\n<li>Again, your Curiosity board may have a different device name but take note of the last two characters (\"S1\") for the device which means that it is the slave core. Select device dsPIC33CH128MP508S1 and Starter Kits (PKOB)-SN:BUR182571251 then click Next.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/select-slave-device.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/select-slave-device-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/select-slave-device-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/select-slave-device-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/select-slave-device-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/select-slave-device-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/select-slave-device-2xl.jpg 1600w\"  alt=\"MPLAB Select slave device\" width=\"910\" height=\"631\"></figure></li>\n<li>Select compiler XC16 (v1.70) then click Next.</li>\n<li>Name the project as \"slave\" and use the same project location with the master core. Click Finish.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/slave-project-name-and-folder.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-name-and-folder-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-name-and-folder-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-name-and-folder-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-name-and-folder-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-name-and-folder-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-name-and-folder-2xl.jpg 1600w\"  alt=\"MPLAB slave project name and folder\" width=\"956\" height=\"636\"></figure></li>\n</ol>\n<h2>MASTER CORE CONFIGURATION</h2>\n<ol>\n<li>On the Projects Pane, right click on master and select \"Set as Main Project\".<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/MPLAB_Set_main_project.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_Set_main_project-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_Set_main_project-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_Set_main_project-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_Set_main_project-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_Set_main_project-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_Set_main_project-2xl.jpg 1600w\"  alt=\"MPLAB master set as main project\" width=\"412\" height=\"671\"></figure></li>\n<li>Click the MCC button <figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/mcc-button.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/mcc-button-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/mcc-button-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/mcc-button-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/mcc-button-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/mcc-button-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/mcc-button-2xl.jpg 1600w\"  alt=\"MCC button\" width=\"45\" height=\"42\"></figure>on the toolbox and wait until the MCC program has loaded. It takes a while to load on my PC. A master.mc3 file will also be discreetly created in the root of the master project folder (..\\master.x\\master.mc3).</li>\n<li>In the device resources pane, click the \"+\" of the SLAVE CORE.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/device-resources-slave-core.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-slave-core-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-slave-core-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-slave-core-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-slave-core-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-slave-core-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-slave-core-2xl.jpg 1600w\"  alt=\"MCC Device Resources Slave Core\" width=\"247\" height=\"317\"></figure><br>After clicking the \"+\", the slave core should appear on the project resources pane.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/project-resources-slave-core.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/project-resources-slave-core-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/project-resources-slave-core-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/project-resources-slave-core-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/project-resources-slave-core-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/project-resources-slave-core-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/project-resources-slave-core-2xl.jpg 1600w\"  alt=\"MCC Project Resources  - Slave Core\" width=\"246\" height=\"251\"></figure></li>\n<li>In the Slave Core Pane, name the Slave as \"slave\". Enable Protocol A and Protocol B. Set Protocol A Direction as M-&gt;S.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/master-slave-core-configuration.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-core-configuration-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-core-configuration-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-core-configuration-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-core-configuration-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-core-configuration-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-core-configuration-2xl.jpg 1600w\"  alt=\"MCC master slave peripheral configuration\" width=\"807\" height=\"517\"></figure>In the Slave Clock settings of the Slave Core pane, set Clock Output Pin Configuration as \"OSC2 is general purpose digital I/O pin\".<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/master-slave-peripheral-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-peripheral-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-peripheral-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-peripheral-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-peripheral-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-peripheral-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-slave-peripheral-2-2xl.jpg 1600w\"  alt=\"slave peripheral clock pin\" width=\"587\" height=\"441\"></figure></li>\n<li>In the Pin Manager Pane, set RB2, RC3, RC6 and RC14 as owned by the Slave Core. RB2 will be used as monitor for an analog signal from DAC inside the dsPIC. RC3 will be used as monitor for the output of the first comparator inside the dsPIC. RC6 will be used as monitor for the output of the second comparator inside the dsPIC. RC14 will be used as the output of the SR logic and used to drive the buck MOSFET Q6.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/master-pin-manager.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/master-pin-manager-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-pin-manager-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-pin-manager-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-pin-manager-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-pin-manager-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-pin-manager-2xl.jpg 1600w\"  alt=\"MPLAB master slave peripheral ownership\" width=\"1262\" height=\"473\"></figure></li>\n<li>In the System Module Pane, set clock output pin as \"OSC2 is general purpose digital I/O pin\".\n<h2><br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/master-clock-output-pin-configuration.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/master-clock-output-pin-configuration-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-clock-output-pin-configuration-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-clock-output-pin-configuration-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-clock-output-pin-configuration-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-clock-output-pin-configuration-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/master-clock-output-pin-configuration-2xl.jpg 1600w\"  alt=\"MCC master clock output pin configuration\" width=\"640\" height=\"247\"></figure></h2>\n</li>\n<li><span style=\"color: var(--text-editor-body-color); font-family: var(--font-base); font-size: inherit; font-weight: var(--font-weight-normal);\">Go back to the Slave Core Pane and click Save Master Settings button. A file named master_config.mc3 will be discreetly generated on the root of the master folder after you click the Save Master Settings button.</span></li>\n<li>Lastly for the master configuration, click the Generate button on the Project Resources pane. If there are warnings, review first the Notifications [MCC] pane.</li>\n<li>After confirmation on the generate configuration, you should see a Generation complete on the text output window. After that, close the configuration by clicking the MCC toolbar button.</li>\n</ol>\n<h2>SLAVE CORE CONFIGURATION</h2>\n<ol>\n<li>On the Projects Pane, right click on the slave project and select as Main Project.</li>\n<li>Click on the MCC button on the toolbar. Wait until the MCC application is completely loaded. A file named slave.mc3 will also be discreetly generated on the root of the slave project folder (..\\slave.x\\slave.mc3).</li>\n<li>Go to the Master Core Pane then click Load Slave Settings from Master Configuration button.</li>\n<li>In the Load Master Settings dialog box, browse to the master core folder and open the master_config.mc3 file.</li>\n<li>In the System Module tab, tick PLL enable, select 1:100 as Feedback, select FVCO/2 as VCO Divider and select FVCO/2 as AVCO Divider. These settings are needed for the comparator to operate.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/system-module-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/system-module-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/system-module-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/system-module-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/system-module-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/system-module-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/system-module-2-2xl.jpg 1600w\"  alt=\"MCC Slave System module\" width=\"510\" height=\"703\"></figure></li>\n<li>In the Device Resources window, click on the \"+\" of the ADC1 to transfer it to the Project Resources.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/device-resources-adc1.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-adc1-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-adc1-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-adc1-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-adc1-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-adc1-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-adc1-2xl.jpg 1600w\"  alt=\"MCC device resources - ADC1\" width=\"354\" height=\"242\"></figure></li>\n<li>In the ADC1 tab, tick Enable of Core1. Select S1ANA1 as the Core Channel of Core1. S1ANA1 is connected to the RC1_VOUTFB (output voltage sense) of the dsPIC IC. Select Common Software Trigger as the Trigger Source of Core1. Tick Interrupt of Core1.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/adc1-settings.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/adc1-settings-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/adc1-settings-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/adc1-settings-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/adc1-settings-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/adc1-settings-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/adc1-settings-2xl.jpg 1600w\"  alt=\"MCC Slave ADC configuration\" width=\"854\" height=\"423\"></figure></li>\n<li>In the Device Resources pane, click the \"+\" of the TMR1 to move the timer peripheral to the Project Resources.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/device-resources-tmr1.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-tmr1-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-tmr1-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-tmr1-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-tmr1-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-tmr1-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-tmr1-2xl.jpg 1600w\"  alt=\"MCC Device Resources timer\" width=\"356\" height=\"230\"></figure></li>\n<li>In the TMR1 tab, type 25 us on the Timer Period and tick the Enable Timer Interrupt. This timer will be used to call the program that will trigger the ADC peripheral that we previously configured.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/TMR1-settings.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/TMR1-settings-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/TMR1-settings-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/TMR1-settings-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/TMR1-settings-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/TMR1-settings-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/TMR1-settings-2xl.jpg 1600w\"  alt=\"MCC TMR1 peripheral settings\" width=\"752\" height=\"423\"></figure></li>\n<li>In the Device Resources pane, click the \"+\" of the CMP1 to move the CMP1 peripheral to the Project Resources.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/device-resources-cmp1.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp1-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp1-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp1-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp1-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp1-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp1-2xl.jpg 1600w\"  alt=\"MCC Device resources CMP1\" width=\"358\" height=\"243\"></figure></li>\n<li>In the CMP1 tab, tick the Enable Comparator, type 400 MHz on the Clock Frequency and tick the Enable DAC output. Note that the Non-Inverting Input default is set to S1CMP1A where RA3_ISENSEH (high side current sense) pin is connected. Ticking the Enable DAC output means that the DAC output that is connected to the inverting input of the comparator will also be connected to DACOUT pin (RB2). We are doing this to monitor the analog output of the DAC.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/CMP1-settings.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/CMP1-settings-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/CMP1-settings-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/CMP1-settings-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/CMP1-settings-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/CMP1-settings-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/CMP1-settings-2xl.jpg 1600w\"  alt=\"MCC CMP1 settings\" width=\"589\" height=\"573\"></figure></li>\n<li>  In the Device Resources pane, click on the \"+\" of the PGA2 (programmable gain amplifier) to move the PGA to the Project Resources. We are selecting PGA2 because it is the peripheral connected to the RD14_ISENSEL (low side current sense) pin of the dsPIC which needs to be amplified with -8 gain.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/device-resources-pga2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-pga2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-pga2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-pga2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-pga2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-pga2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-pga2-2xl.jpg 1600w\"  alt=\"MCC device resources PGA\" width=\"359\" height=\"244\"></figure></li>\n<li>In the PGA2 tab, change the Gain to 8x, Negative Input to S1PGA2N2 and Positive Input to Ground. S1PGA2N2 is the one that is connected to RD14_ISENSEL pin of the dsPIC. Note that we connect the sense to the negative input and ground to the positive input of the amplifier to have a negative gain.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/pga2-settings.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/pga2-settings-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/pga2-settings-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/pga2-settings-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/pga2-settings-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/pga2-settings-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/pga2-settings-2xl.jpg 1600w\"  alt=\"MCC PGA settings\" width=\"481\" height=\"268\"></figure></li>\n<li>In the Device Resources pane, click on the \"+\" of the CMP2 to transfer it to the Project Resources.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/device-resources-cmp2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-cmp2-2xl.jpg 1600w\"  alt=\"MCC Device Resources  - CMP2\" width=\"364\" height=\"245\"></figure></li>\n<li>In the CMP2 tab, tick the Enable Comparator, type 400 MHz on the Clock Frequency, select SPGA2 Output as the Non-Inverting Input, tick Inverted and tick Enable Digital Filter. <br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/cmp2-savings.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/cmp2-savings-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/cmp2-savings-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/cmp2-savings-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/cmp2-savings-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/cmp2-savings-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/cmp2-savings-2xl.jpg 1600w\"  alt=\"MCC CMP2 configuration\" width=\"589\" height=\"571\"></figure></li>\n<li>In the Device Resources pane, click the \"+\" of the CLC1 (Configurable Logic Cell) to transfer it to the Project Resources.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/device-resources-clc1.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-clc1-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-clc1-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-clc1-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-clc1-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-clc1-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/device-resources-clc1-2xl.jpg 1600w\"  alt=\"MCC Device Resources - CLC1\" width=\"361\" height=\"242\"></figure></li>\n<li>In the CLC1 tab, tick the Enable CLC Output, select SR latch as Mode, select Slave CMP1 output and Slave CMP2 output as inputs of the CLC, Connect Slave CMP1 output to Gate 3, Connect Slave CMP2 to Gate 2 and set the CLCOUT as inverted. The CLCOUT will be configured after to connect to RC14_S1PWM7H pin to drive the buck MOSFET Q6. It is needed to invert the output because Q6 is a p-type MOSFET that need negative gate-source voltage to turn on.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/clc1-settings.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/clc1-settings-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/clc1-settings-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/clc1-settings-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/clc1-settings-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/clc1-settings-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/clc1-settings-2xl.jpg 1600w\"  alt=\"MCC CLC1 configuration\" width=\"1038\" height=\"649\"></figure></li>\n<li>In the Pin Manager Tab, connect S1CLC1OUT to RC14, S1CMP1 to RC3 and S1CMP2 to RC6.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/slave-pin-manager.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/slave-pin-manager-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-pin-manager-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-pin-manager-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-pin-manager-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-pin-manager-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-pin-manager-2xl.jpg 1600w\"  alt=\"MCC Slave pin manager\" width=\"866\" height=\"445\"></figure></li>\n<li>In the Pin Module Tab, type RC1_VOUTFB in the Custom Name of RC1.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/pin-module.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/pin-module-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/pin-module-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/pin-module-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/pin-module-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/pin-module-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/pin-module-2xl.jpg 1600w\"  alt=\"MCC Slave Pin Module\" width=\"504\" height=\"340\"></figure></li>\n<li>In the Notifications [MCC] tab, review the messages. I usually will have the same as below.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/MCC-slave-notifications.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/MCC-slave-notifications-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MCC-slave-notifications-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MCC-slave-notifications-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MCC-slave-notifications-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MCC-slave-notifications-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MCC-slave-notifications-2xl.jpg 1600w\"  alt=\"MCC Slave notification \" width=\"919\" height=\"334\"></figure></li>\n<li>In the Project Resources pane, click Generate button. Click Yes to disregard the warnings and proceed generating the source files. Wait until a \"Generation complete\" text appears on the MPLAB Code Configurator prompt window.</li>\n<li>Close the code configurator by clicking the MCC toolbar button.</li>\n</ol>\n<h2>ADD SLAVE TO MASTER BUILD</h2>\n<ol>\n<li>Right click on the Secondaries folder of master project and click Add Secondary Project...<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/MPLAB_add_secondary_project.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_add_secondary_project-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_add_secondary_project-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_add_secondary_project-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_add_secondary_project-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_add_secondary_project-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/MPLAB_add_secondary_project-2xl.jpg 1600w\"  alt=\"MPLAB add slave to compile\" width=\"387\" height=\"375\"></figure></li>\n<li>In the Add Secondary Project dialog box, find and select the slave.X folder and click Add.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/Add-secondary-project.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/Add-secondary-project-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/Add-secondary-project-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/Add-secondary-project-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/Add-secondary-project-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/Add-secondary-project-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/Add-secondary-project-2xl.jpg 1600w\"  alt=\"MPLAB Add secondary project dialog box\" width=\"898\" height=\"423\"></figure></li>\n<li>Right click again on the Secondaries Folder and select Properties. Tick the Build box of the properties dialog windows then click OK.</li>\n</ol>\n<h2>MAIN PROGRAM</h2>\n<ol>\n<li>Open the slave project's main.c file.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/slave-project-main.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-main-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-main-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-main-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-main-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-main-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/slave-project-main-2xl.jpg 1600w\"  alt=\"MPLAB Slave project main.c\" width=\"294\" height=\"261\"></figure></li>\n<li>Replace the main.c file contents with below code. The program has two interrupt handler functions, MyTimer and PID. MyTimer is called every 25us as we configured it on the MCC previously. MyTimer will just enable the software common trigger ( SWCTRG) bit of ADC1. When SWCTRG is enabled, the PID function will be called then the ADC1 will automatically disable back the SWCTRG. The last line of the PID function changes the value of DAC1DATH. DAC1DATH value is the one that is converted into analog that is fed to the CMP1 - input.<br><code>#include \"mcc_generated_files/system.h\"<br>#include \"mcc_generated_files/pin_manager.h\"<br>#include \"mcc_generated_files/adc1.h\"<br>#include \"mcc_generated_files/tmr1.h\"<br><br>/*PID function and variable definitions*/<br>void PID(void);<br>void MyTimer(void);<br>volatile int16_t n16_integrator_memory;<br>volatile int16_t n16_reference;<br>int16_t n16_error;<br>int16_t n16_proportional;<br><br>#define target_voltage  3.3<br>#define reference       666.7*target_voltage + 70<br>#define p_gain          0.5<br>#define i_gain          0.1<br><br>int main(void)<br>{<br>    // initialize the device<br>    SYSTEM_Initialize();<br>    //Initialize PID variables<br>    n16_integrator_memory = 0;<br>    n16_reference = (int16_t) reference;<br>    DAC2DATH = 20;<br>    //Assign Interrupt Handlers<br>    ADC1_SetRC1_VOUTFBInterruptHandler(PID);<br>    TMR1_SetInterruptHandler(MyTimer);<br>    while (1)<br>    {<br>        // Add your application code<br>    }<br>    return 1; <br>}<br>void MyTimer(void)<br>{<br>    ADCON3Lbits.SWCTRG = 1;<br>}<br>void PID(void)<br>{<br>    n16_error = n16_reference - ADCBUF1;<br>    n16_integrator_memory = n16_integrator_memory + i_gain*n16_error;<br>    n16_proportional = p_gain*n16_error;<br>    DAC1DATH = n16_integrator_memory + n16_proportional+290;<br>}</code></li>\n<li>Right click on the master project and select Set as Main Project.</li>\n<li>Open the master projects main.c file.</li>\n<li>Paste the following codes after the line with SYSTEM_Initialize();<br> <code>SLAVE1_Program();<br>  SLAVE1_Start();</code></li>\n<li>Click the Make and Program Device Main Project button <figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/make-and-program-device-main-project-button.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/make-and-program-device-main-project-button-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/make-and-program-device-main-project-button-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/make-and-program-device-main-project-button-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/make-and-program-device-main-project-button-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/make-and-program-device-main-project-button-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/make-and-program-device-main-project-button-2xl.jpg 1600w\"  alt=\"MPLAB make and program device main project\" width=\"34\" height=\"29\"></figure>. Wait until Programming/Verify complete is prompted in the text output window.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/mplab-window-programming-verify-complete.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/mplab-window-programming-verify-complete-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/mplab-window-programming-verify-complete-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/mplab-window-programming-verify-complete-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/mplab-window-programming-verify-complete-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/mplab-window-programming-verify-complete-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/mplab-window-programming-verify-complete-2xl.jpg 1600w\"  alt=\"MPLAB programming/verify complete\" width=\"437\" height=\"316\"></figure></li>\n</ol>\n<h2>RESULT</h2>\n<ol>\n<li>Below waveforms are 3.3V Vout (Orange), Buck MOSFET Q6 drive (Purple) which is measured from pin RC14, CMP1 (Blue 2nd from the bottom) which is measured from pin RC3 and CMP2 (Blue, most bottom) which is measured from pin RC6. Duty is 62% while Frequency is 462kHz. Actually, by ignoring the diode drop and other losses we can confirm the -duty by the formula Vout/Vin =  66% which is near the measured -duty. -Duty is measured here because of the reverse gate voltage requirement of Q6. <br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/result-Vout-Q6-CMP1-CMP2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/result-Vout-Q6-CMP1-CMP2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-Vout-Q6-CMP1-CMP2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-Vout-Q6-CMP1-CMP2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-Vout-Q6-CMP1-CMP2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-Vout-Q6-CMP1-CMP2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-Vout-Q6-CMP1-CMP2-2xl.jpg 1600w\"  alt=\"Scopy \" width=\"1096\" height=\"582\"></figure></li>\n<li>I want to measure the current sense signal on pin RA3 but I realize my scope probe impedance effect is significant for the circuit to handle. When I connect the probe to RA3, the CMP1 output goes abnormal so first I am measuring the voltage on the DAC of CMP1 to know what peak voltage on RA3 before Q6 turns off. Below orange waveform is the DAC waveform and has a mean value of 323mV.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/result-CMP1-DAC-Q6-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/result-CMP1-DAC-Q6-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-CMP1-DAC-Q6-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-CMP1-DAC-Q6-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-CMP1-DAC-Q6-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-CMP1-DAC-Q6-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-CMP1-DAC-Q6-2-2xl.jpg 1600w\"  alt=\"scopy\" width=\"1053\" height=\"568\"></figure></li>\n<li>Instead of measuring directly the high side current sense RA3 signal, we can utilize another built-in PGA inside the dsPIC to measure it and then we measure the output of the PGA.</li>\n<li>Right click on the slave project and set it as the Main Project.</li>\n<li>Click the MCC button on the toolbar menu and wait the MCC application to load completely.</li>\n<li>On the Master Core tab, click the Load Slave Settings from Master Configuration button and find/select the master_config.mc3 file.</li>\n<li>Add the PGA1 from the Device Resources Pane to the Project Resources.</li>\n<li>Click the Generate button on the Project Resources pane then click Yes on the MCC Confirmation warnings dialog box.</li>\n<li>Close the MCC application by clicking the MCC button on the toolbar menu.</li>\n<li>On the slave project's main.c file, add the following code after the line with TMR1_SetInterruptHandler(MyTimer); . <br><code>DAC1CONLbits.DACOEN = 0;<br> PGA1CONbits.PGAOEN = 1;</code> <br>These two lines means that the PGA1 is connected to RB2 instead of the CMP1's DAC.</li>\n<li>Right click on master project and select Set as Main Project.</li>\n<li>Click Make and Program Device Main Project button on the toolbar menu. Wait until Programming/Verify Complete is prompted in the output text window.</li>\n<li>The orange waveform below is the voltage on RB2 which is now the PGA1 output and is the voltage measured on RA3 (high side current sense) multiplied by 4. The peak current is about 1.36V. 1.36V/4 = 340mV which is has similar value with the CMP1 DAC output.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/result-PGA1-Q6.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA1-Q6-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA1-Q6-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA1-Q6-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA1-Q6-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA1-Q6-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA1-Q6-2xl.jpg 1600w\"  alt=\"scopy\" width=\"1012\" height=\"581\"></figure></li>\n<li>Next we try what waveform we can see on the low side current sense. Since this is also a very small level signal and I do not have a good low impedance probe, we will measure the PGA output instead of measuring directly the signal at pin RD14.</li>\n<li>On the slave project's main.c file, change PGA1CONbits.PGAOEN = 1; to <code>PGA<strong>2</strong>CONbits.PGAOEN = 1;</code>.</li>\n<li>Click Make and Program Device Main Project button on the toolbar menu. Wait until Programming/Verify Complete is prompted in the output text window.</li>\n<li>The orange waveform below is now the PGA2 output which is the voltage measured on RD14 (low side current sense) multiplied by 8. I changed the voltage per division to make the signal larger on the screen. The peak voltage is only 130mV. 130mV/8 = 16.25mV is the peak voltage on RD14 which is too small if we use an ordinary passive probe.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/11/result-PGA2-Q6-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA2-Q6-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA2-Q6-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA2-Q6-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA2-Q6-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA2-Q6-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/11/responsive/result-PGA2-Q6-2-2xl.jpg 1600w\"  alt=\"scopy\" width=\"1015\" height=\"567\"></figure></li>\n</ol>\n<p> </p>\n<p> </p>\n<p> </p>\n<p>\n<script async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2158060120252492\" crossorigin=\"anonymous\"></script>\n</p>",
            "author": {
                "name": "Andrew Mosqueda"
            },
            "tags": [
            ],
            "date_published": "2021-11-24T20:07:35+08:00",
            "date_modified": "2021-11-28T19:39:01+08:00"
        },
        {
            "id": "https://andrewmosqueda.github.io/ltspice-simulation-of-hysteretic-control-for-buck-converter/",
            "url": "https://andrewmosqueda.github.io/ltspice-simulation-of-hysteretic-control-for-buck-converter/",
            "title": "LTspice simulation of hysteretic current control for buck converter",
            "summary": " In this article, LTspice simulation of a 5V to 3.3V buck converter using hysteretic current control is presented. The circuit simulated here is the power circuit included in the DM330028 dsPIC33CH Curiosity Developement Board. The control method is an emulation of components and programming&hellip;",
            "content_html": "<p>\n<script async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2158060120252492\" crossorigin=\"anonymous\"></script>\n</p>\n<h2>INTRODUCTION</h2>\n<p>In this article, LTspice simulation of a 5V to 3.3V buck converter using hysteretic current control is presented. The circuit simulated here is the power circuit included in the DM330028 dsPIC33CH Curiosity Developement Board. The control method is an emulation of components and programming of dsPIC33CH. The aim of the simulation is to have an insight on how to configure and program the dsPIC33CH for hysteretic current control.</p>\n<h2>LTSPICE SCHEMATIC</h2>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/10/LTspice-simulation-5.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/10/responsive/LTspice-simulation-5-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/10/responsive/LTspice-simulation-5-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/10/responsive/LTspice-simulation-5-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/10/responsive/LTspice-simulation-5-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/10/responsive/LTspice-simulation-5-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/10/responsive/LTspice-simulation-5-2xl.jpg 1600w\"  alt=\"Hysteretic current mode converter LTspice\" width=\"867\" height=\"877\"></figure>\n<h5>POWER CIRCUIT</h5>\n<p>In hysteretic mode, the MOSFET Q6 is switch on until a predetermined peak current is reached. During turn off, the controller will turn on again the MOSFET when the current flowing on the mosfet returns to 0 ampere. The power circuit output level is inherently inversely proportional to the switching frequency of MOSFET Q6 while the duty cycle does not change much. All the components on the power circuit except the Rload resistor can be found on FIGURE A-3 of the DS50002762A document from microchip. I put 100Ω resistor as Rload because it is the one I use as actual load for the 3.3V output. Note also that MOSFET Q6 is a P-Type so a low-level voltage is needed at the gate to turn it on.</p>\n<h5>HIGH SIDE CURRENT SENSE</h5>\n<p>This circuit is used for sensing the current on MOSFET Q6. The output of the high side current sense circuit is fed to the analog comparator CMP1. Below waveform ra3_isenseh is the output of this circuit and compared to the gate drive rc14 waveform. Note that when Q6 is turned off, R63_92_93 is used as low side current sensing circuit instead. All the components on the high side current circuit can also be found on FIGURE A-3 of the DS50002762A document from microchip. The operation of the circuit is also explained in the same document.  <figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/10/high-side-current-sense-vs-mosfet-drive.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/10/responsive/high-side-current-sense-vs-mosfet-drive-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/10/responsive/high-side-current-sense-vs-mosfet-drive-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/10/responsive/high-side-current-sense-vs-mosfet-drive-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/10/responsive/high-side-current-sense-vs-mosfet-drive-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/10/responsive/high-side-current-sense-vs-mosfet-drive-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/10/responsive/high-side-current-sense-vs-mosfet-drive-2xl.jpg 1600w\"  alt=\"high side current sense vs mosfet gate drive\" width=\"914\" height=\"884\"></figure>\n<h5>ADC1</h5>\n<p> This ADC module is the one used for sensing the output voltage of the power circuit. The output of the ADC is a digital representation of the sensed output voltage and is fed to or is used by the PID program (C CODE IN MPLAB). This circuit is a mathematical equivalent of the ADC module of the dsPIC33CH. I derived the equation based from my experiment.</p>\n<h5>CMP1</h5>\n<p>The CMP1 module compares the MOSFET Q6 current (from high side current sense circuit) to the peak current limit PGDC that is calculated by the PID program (C CODE in MPLAB). In MPLAB, i will select 400MHz as the clock frequency of the comparator so I put tau=7.5n (consider also the effect of pulse stretcher). Setting tau=7.5n also will make the simulation faster. The output of the CMP1 is used as terminator for the CLC1 module. Below are the terminator waveform and comparator outputs ra3_isenseh and dac.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/10/terminator.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/10/responsive/terminator-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/10/responsive/terminator-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/10/responsive/terminator-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/10/responsive/terminator-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/10/responsive/terminator-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/10/responsive/terminator-2xl.jpg 1600w\"  alt=\"comparator output\" width=\"899\" height=\"878\"></figure>\n<h5>C CODE IN MPLAB</h5>\n<p>LTspice has no c code so this circuit is just a representation of the PID c code that I will use in MPLAB. Below is the MPLAB PID c code that I usually use. The LTspice element B4 is used to calculate the error which is the difference of the reference and the output of the ADC1. The 2nd line in the PID code below is done by my own LTspice integrator circuit. The integrator circuit operation can be found in this link <a href=\"https://andrewmosqueda.github.io/implementing-a-discrete-integrator-in-ltspice/\" target=\"_blank\" rel=\"noopener noreferrer\"></a> <a href=\"https://andrewmosqueda.github.io/implementing-a-discrete-integrator-in-ltspice/\" target=\"_blank\" rel=\"noopener noreferrer\">LTspice integrator.</a> The LTspice element B7 is used to calculate the proportional portion of the PID. The output of the PID is then fed to the DAC1DATH register of ADC1.</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/10/pid-code-3.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/10/responsive/pid-code-3-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/10/responsive/pid-code-3-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/10/responsive/pid-code-3-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/10/responsive/pid-code-3-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/10/responsive/pid-code-3-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/10/responsive/pid-code-3-2xl.jpg 1600w\"  alt=\"PID c code in MPLAB\" width=\"567\" height=\"125\"></figure>\n<h5>PGA2</h5>\n<p>The low side current sense resistor R63_92_93 of the power circuit has a negative level with respect to the current flow on D2. In order to become positive level, the output of the current sense is fed into the negative input of the PGA (programmable gain amplifier). The PGA gain is set to 8 as recommended in the DS50002762A document. The output of the PGA is fed into another comparator CMP2. </p>\n<h5>CMP2</h5>\n<p>This comparator outputs high when the output of the low side current sense becomes 0. The output of this comparator is used to set high the CLC1 circuit. Below is the start waveform and the input to the comparator (blue waveform). The settings of the this comparator is the same with CMP1 except that its negative input is fixed at 0.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/10/start.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/10/responsive/start-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/10/responsive/start-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/10/responsive/start-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/10/responsive/start-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/10/responsive/start-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/10/responsive/start-2xl.jpg 1600w\"  alt=\"comparator output\" width=\"940\" height=\"880\"></figure>\n<h5>CLC1</h5>\n<p>This circuit is a representation of the dsPIC33's CLC (configurable Logic Cell) configured as an SR flip-flop. This circuit outputs low when START input becomes high and outputs high when Terminator input becomes high. <figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/10/CLC1-output.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/10/responsive/CLC1-output-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/10/responsive/CLC1-output-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/10/responsive/CLC1-output-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/10/responsive/CLC1-output-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/10/responsive/CLC1-output-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/10/responsive/CLC1-output-2xl.jpg 1600w\"  alt=\"SR flip flop operation\" width=\"941\" height=\"878\"></figure>\n<h2>LTSPICE FILES</h2>\n<p>Download LTspice files here: <a href=\"https://andrewmosqueda.github.io/media/files/Hysteretic Current Mode Converter.zip\" target=\"_blank\" rel=\"noopener noreferrer\">LTspice Hysteretic Current Mode Converter</a></p>",
            "author": {
                "name": "Andrew Mosqueda"
            },
            "tags": [
            ],
            "date_published": "2021-11-20T22:27:18+08:00",
            "date_modified": "2021-11-28T16:47:59+08:00"
        },
        {
            "id": "https://andrewmosqueda.github.io/using-the-slope-compensation-for-the-current-mode-control/",
            "url": "https://andrewmosqueda.github.io/using-the-slope-compensation-for-the-current-mode-control/",
            "title": "Using the slope compensation for the current mode control",
            "summary": " In the DC Mode, the output of the DAC changes only after the DACDATAH is updated. Actually, the DAC has a slope compensation feature in which the output of the DAC ramps down after DACDATAH is updated. This method makes the control more stable.",
            "content_html": "<p>\n<script async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2158060120252492\" crossorigin=\"anonymous\"></script>\n</p>\n<h2>INTRODUCTION</h2>\n<figure class=\"post__image\">In the previous article <a href=\"https://andrewmosqueda.github.io/current-mode/\" target=\"_blank\" rel=\"noopener noreferrer\"></a><a href=\"https://andrewmosqueda.github.io/current-mode/\" target=\"_blank\" rel=\"noopener noreferrer\">Current Mode Converter</a> , the PWM control is generated based from the comparison of the output of the DAC to the actual current of the high side mosfet. See illustration below.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/9/close-loop.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/9/responsive/close-loop-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/9/responsive/close-loop-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/9/responsive/close-loop-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/9/responsive/close-loop-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/9/responsive/close-loop-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/9/responsive/close-loop-2xl.jpg 1600w\"  alt=\"Current Controlled Buck Converter\" width=\"983\" height=\"578\"></figure>\n<figure class=\"post__image\">The DAC converts the digital result value of the PID function  into analog. The DAC was configured in DC Mode as seen on the image below.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/9/CMP-DC-Mode.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-DC-Mode-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-DC-Mode-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-DC-Mode-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-DC-Mode-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-DC-Mode-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-DC-Mode-2xl.jpg 1600w\"  alt=\"Comparator in DC Mode\" width=\"679\" height=\"519\"></figure>\n<p>In the DC Mode, the output of the DAC changes only after the DACDATAH is updated.</p>\n<p>Actually, the DAC has a slope compensation feature in which the output of the DAC ramps down after DACDATAH is updated. This method makes the control more stable. In this article I will configure the DAC from DC Mode to slope compensation mode. </p>\n<h2>PROCEDURE</h2>\n<ol>\n<li>Open the master and slave projects of the current mode buck control in MPLAB IDE. The MPLAB code of the buck control project is stored here: <a href=\"https://andrewmosqueda.github.io/media/files/buck_ictrl.zip\" target=\"_blank\" rel=\"noopener noreferrer\">buck_ictrl.zip</a></li>\n<li>Right click on the master project and make it the main project.</li>\n<li>Connect the DM330028 board to the PC. Click the \"Make and Program\" button on MPLAB to program the code to the dsPIC33 IC. Wait until a \"Programming/Verify complete\" message is prompted in the output window of MPLAB.</li>\n<li>If we connect an oscilloscope to RB2 and RA3, we would see the waveform below. We can see that the orange waveform (RA3) shuts off after reaching the purple waveform (RB2). The RB2 is the DC value output from the DAC and RA3 is the current sense signal that is fed to the comparator. Note: RB2 is not shown in the simplified schematic that is illustrated above.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/9/RA3vsRB2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/9/responsive/RA3vsRB2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/9/responsive/RA3vsRB2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/9/responsive/RA3vsRB2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/9/responsive/RA3vsRB2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/9/responsive/RA3vsRB2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/9/responsive/RA3vsRB2-2xl.jpg 1600w\"  alt=\"waveform current mode\" width=\"1377\" height=\"768\"></figure></li>\n<li>Right click on the slave project and make it the main project.</li>\n<li>Click MCC button and wait until the slave MCC is completely loaded.</li>\n<li>After the MCC is loaded, open the Master Core Configuration.</li>\n<li>In the Master Core Configuration window, click \"Load Slave Settings from Master Configuration\" button. Select the master_config.mc3 file in the master.X folder then click Open button. Wait until the Notifications [MCC] window is updated.</li>\n<li>In the Project Resources window, click CMP1 (Don't click X) to open the CMP1 analog comparator window. Wait until the window is completely loaded.</li>\n<li>Configure the DAC as shown below. I made the lowest value DACDATAL as 260 because this is 0 current offset value of the DM330028 current sense amplifier. In this configuration, the DAC output will start to ramp down after Slave PWM7 Trigger 1 and ramps back up after either Slave PWM7 Trigger2 or S1CMP1 Output is triggered.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/9/CMP-Slope-Mode.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-Slope-Mode-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-Slope-Mode-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-Slope-Mode-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-Slope-Mode-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-Slope-Mode-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/9/responsive/CMP-Slope-Mode-2xl.jpg 1600w\"  alt=\"Slope Mode Current Control\" width=\"1121\" height=\"672\"></figure></li>\n<li>In the Project Resources window, click PWM (Don't click X) to open the PWM window. Wait until the window is completely loaded.</li>\n<li>Expand the Trigger Control Settings and configure it as shown below. Trigger 1 is triggered 1us after the start of PWM cycle. We have now configure the DAC output to start ramping down after 1us after the start of PWM cycle. Trigger 2 is triggered 25us after the start of PWM cycle. 25us is the period of the 40kHz PWM so the DAC output will go back to DACDATH at the end of the PWM cycle.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/9/Trigger-Control-Settings-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/9/responsive/Trigger-Control-Settings-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/9/responsive/Trigger-Control-Settings-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/9/responsive/Trigger-Control-Settings-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/9/responsive/Trigger-Control-Settings-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/9/responsive/Trigger-Control-Settings-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/9/responsive/Trigger-Control-Settings-2-2xl.jpg 1600w\"  alt=\"PWM Trigger Settings\" width=\"696\" height=\"394\"></figure></li>\n<li>Click the Generate button. Click yes button in the confirmation dialog box and wait until Generation complete is prompted in the MCC output window.</li>\n<li>Click MCC toolbar button to close the MCC configurator application.</li>\n<li>In the projects pane, open main.c file of the slave project.</li>\n<li>In the PID function, add the highlighted code as shown below. <br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/9/PID-function.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/9/responsive/PID-function-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/9/responsive/PID-function-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/9/responsive/PID-function-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/9/responsive/PID-function-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/9/responsive/PID-function-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/9/responsive/PID-function-2xl.jpg 1600w\"  alt=\"PID function\" width=\"773\" height=\"147\"></figure>260 is the assigned value of the DAC1DATL. The multiplier 0.003 calculation is shown below.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/9/multipler.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/9/responsive/multipler-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/9/responsive/multipler-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/9/responsive/multipler-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/9/responsive/multipler-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/9/responsive/multipler-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/9/responsive/multipler-2xl.jpg 1600w\"  alt=\"slope value multiplier calculation\" width=\"479\" height=\"303\"></figure></li>\n<li>Right click on the master project file and set it as the main project.</li>\n<li>Click Make and Program button and wait until the Programming/Verify complete is prompted on the log window.</li>\n</ol>\n<h2>RESULT</h2>\n<figure class=\"post__image\">Purple waveform - DAC output<br>Orange waveform - MOSFET current sense amplifier output<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/9/waveform.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/9/responsive/waveform-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/9/responsive/waveform-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/9/responsive/waveform-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/9/responsive/waveform-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/9/responsive/waveform-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/9/responsive/waveform-2xl.jpg 1600w\"  alt=\"current mode control with slope compensation\" width=\"853\" height=\"476\"></figure>\n<p>It can now be seen that the DAC output (purple) ramps down 1us after the MOSFET begins to conduct (orange waveform) and then quickly return back to high value after the MOSFET has turned off.</p>",
            "author": {
                "name": "Andrew Mosqueda"
            },
            "tags": [
            ],
            "date_published": "2021-11-14T16:12:39+08:00",
            "date_modified": "2021-11-28T16:48:34+08:00"
        },
        {
            "id": "https://andrewmosqueda.github.io/simulation-of-the-pwm-control-input-pci-current-limit-logic-of-dspic33ch/",
            "url": "https://andrewmosqueda.github.io/simulation-of-the-pwm-control-input-pci-current-limit-logic-of-dspic33ch/",
            "title": "Simulation of the PCI-Current Limit Logic of dsPIC33CH",
            "summary": " The dsPIC33CH IC has a PCI CL (PWM Control Input-Current Limit) Logic that is use for Current Mode Controlled Converter. An equivalent circuit in LTSPICE is simulated to gain better insights of this logic system. The simulated circuit is based on actual circuit values&hellip;",
            "content_html": "<p>\n<script async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2158060120252492\" crossorigin=\"anonymous\"></script>\n</p>\n<h2>INTRODUCTION</h2>\n<p>The dsPIC33CH IC has a PCI CL (PWM Control Input-Current Limit) Logic that is use for Current Mode Controlled Converter. An equivalent circuit in LTSPICE is simulated to gain better insights of this logic system. The simulated circuit is based on actual circuit values in the DM330038 dsPIC33CH Curiosity Development Board.</p>\n<p>SIMPLIFIED BUCK CONVERTER SCHEMATIC</p>\n<figure class=\"post__image\">Below is a simplified schematic of the current mode controlled buck converter of the board with connection to the dsPIC33CH IC. The PWM duty cycle is fixed at usually 95%. the PCI CL purpose is to override (block or truncate) the PWM output everytime the output of the current sense circuit exceeds the reference value. The reference value is an analog voltage generated from the PID by a DAC.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/8/close-loop.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/8/responsive/close-loop-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/8/responsive/close-loop-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/8/responsive/close-loop-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/8/responsive/close-loop-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/8/responsive/close-loop-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/8/responsive/close-loop-2xl.jpg 1600w\"  alt=\"Buck Converter with dsPIC33CH\" width=\"983\" height=\"578\"></figure>\n<p>From above figure, we can see that the PCI-CL is part of the PWM Module of the IC.</p>\n<p>PCI DIAGRAM</p>\n<figure class=\"post__image\">Below is the diagram of the PCI from DS70005320B document. <br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/8/pci.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/8/responsive/pci-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/8/responsive/pci-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/8/responsive/pci-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/8/responsive/pci-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/8/responsive/pci-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/8/responsive/pci-2xl.jpg 1600w\"  alt=\"PWM Control Input Logic\" width=\"933\" height=\"656\"></figure>\n<p>The table below are the register values from above diagram that are needed to configure in order for the PCI to become a current limit logic for the current mode converter:</p>\n<table style=\"border-collapse: collapse; width: 73.5462%;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 19.3732%;\"><strong>Register</strong></td>\n<td style=\"width: 10.9378%;\"><strong>Hex Value</strong></td>\n<td style=\"width: 56.2236%;\"><strong>Value Definition</strong></td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">PSS</td>\n<td style=\"width: 10.9378%;\">28</td>\n<td style=\"width: 56.2236%;\">Slave 1 Comparator 1 output</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">PPS</td>\n<td style=\"width: 10.9378%;\">0</td>\n<td style=\"width: 56.2236%;\">Not inverted</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">PSYNC</td>\n<td style=\"width: 10.9378%;\">0</td>\n<td style=\"width: 56.2236%;\">disabled</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">AQSS</td>\n<td style=\"width: 10.9378%;\">2</td>\n<td style=\"width: 56.2236%;\">LEB is Active</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">AQPS</td>\n<td style=\"width: 10.9378%;\">1</td>\n<td style=\"width: 56.2236%;\">Inverted</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">TERM</td>\n<td style=\"width: 10.9378%;\">1</td>\n<td style=\"width: 56.2236%;\">Auto-Terminate</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">SWTERM</td>\n<td style=\"width: 10.9378%;\">0</td>\n<td style=\"width: 56.2236%;\">disabled</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">TSYNCDIS</td>\n<td style=\"width: 10.9378%;\">0</td>\n<td style=\"width: 56.2236%;\">PWM EOC</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">TQSS</td>\n<td style=\"width: 10.9378%;\">0</td>\n<td style=\"width: 56.2236%;\">No Termination Qualifier, Force 1</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">TQPS</td>\n<td style=\"width: 10.9378%;\">0</td>\n<td style=\"width: 56.2236%;\">Not inverted</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">ACP</td>\n<td style=\"width: 10.9378%;\">3</td>\n<td style=\"width: 56.2236%;\">Latched</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">BPEN</td>\n<td style=\"width: 10.9378%;\">0</td>\n<td style=\"width: 56.2236%;\">disabled</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">SWPCI</td>\n<td style=\"width: 10.9378%;\">0</td>\n<td style=\"width: 56.2236%;\">Drives '0'</td>\n</tr>\n<tr>\n<td style=\"width: 19.3732%;\">SWPCIM</td>\n<td style=\"width: 10.9378%;\">0</td>\n<td style=\"width: 56.2236%;\">PCI acceptance logic</td>\n</tr>\n</tbody>\n</table>\n<p>By using the values of the registers in the above table. The PCI logic is simplified to the diagram below.</p>\n<figure class=\"post__image\" ><br><img loading=\"lazy\" src=\"https://andrewmosqueda.github.io/media/posts/8/PCI-CL-Simplified.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simplified-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simplified-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simplified-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simplified-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simplified-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simplified-2xl.jpg 1600w\"  alt=\"PCI Current Limit Logic Simplified Diagram\" width=\"907\" height=\"256\">\n<figcaption >PCI Current Limit Simplified Diagram</figcaption>\n</figure>\n<p>The Leading Edge Blanking (LEB) is a counter circuit that is synchronized with the PWM output and becomes Active after the PWM output becomes high and then resets/stop after the PWM becomes low. The purpose of the LEB is to ignore switching transients. </p>\n<p>The Auto-Terminate is a logic circuit that detects falling signal of the comparator output and is reset every start of PWM cycle.</p>\n<p>LTSPICE SIMULATION CIRCUIT</p>\n<figure class=\"post__image\">Below is the LTSPICE schematic for the simulation of this simplfied current limit logic with the comparator, pwm and power circuit. The Analog Comparator Reference is fixed at 0.75 for debugging purposes. The ADC and PID are not included in this simulation for simplicity. The LEB is replaced by a DFLOP instead of a counter for shorter simulation time. The output POLARITY is inverted because Power MOSFET Q6 needs 0V to turn on.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/8/PCI-CL-Simulation-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simulation-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simulation-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simulation-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simulation-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simulation-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/8/responsive/PCI-CL-Simulation-2-2xl.jpg 1600w\"  alt=\"DSPIC33 PCI Current Limit Simulation LTSPICE\" width=\"942\" height=\"776\"></figure>\n<p>LTSPICE SIMULATION RESULT</p>\n<figure class=\"post__image\">Below are some of the waveforms from the result of the simulation. The first plot pane from the top shows the PWM output running at 95% duty cycle. The 2nd plot pane from the top shows PCI_Active signal which blocks the PWM output. The truncated output PWM7H is shown in the third plot from the top. The red waveform Ix(Q6:S) is the current flow in power MOSFET Q6. The 4th plot from the top shows the momentary pulse from the comparator output PCI_SOURCE when the sense current RA3_ISENSEH reached the reference voltage DAC.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/8/waveforms-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/8/responsive/waveforms-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/8/responsive/waveforms-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/8/responsive/waveforms-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/8/responsive/waveforms-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/8/responsive/waveforms-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/8/responsive/waveforms-2-2xl.jpg 1600w\"  alt=\"DSPIC33 PCI Current Limit Simulation\" width=\"935\" height=\"877\"></figure>\n<p> </p>\n<p>LTSPICE Simulation Files: <a href=\"https://andrewmosqueda.github.io/media/files/DSPIC33 PCI Current Limit Simulation.zip\" target=\"_blank\" rel=\"noopener noreferrer\">DSPIC33 PCI Current Limit Simulation LTSPICE</a></p>\n<p> </p>\n<p> </p>\n<p> </p>",
            "author": {
                "name": "Andrew Mosqueda"
            },
            "tags": [
            ],
            "date_published": "2021-09-26T17:12:03+08:00",
            "date_modified": "2021-11-28T16:48:49+08:00"
        },
        {
            "id": "https://andrewmosqueda.github.io/high-side-current-sense-circuit-simulation/",
            "url": "https://andrewmosqueda.github.io/high-side-current-sense-circuit-simulation/",
            "title": "High Side Current Sense Circuit Simulation",
            "summary": " LTSPICE simulation files: High Side Current Sense LTSPICE simulation Mathcad files: High Side Current Sense Calculations The high side current sense circuit of DM330028 dsPIC33CH Curiosity Development board as shown below is simulated in LTSPICE and results are shown after. I also included a mathcad&hellip;",
            "content_html": "<p>\n<script async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2158060120252492\" crossorigin=\"anonymous\"></script>\n</p>\n<p>LTSPICE simulation files: <a href=\"https://andrewmosqueda.github.io/media/files/high_side_current_sense.zip\" target=\"_blank\" rel=\"noopener noreferrer\">High Side Current Sense LTSPICE simulation</a></p>\n<p>Mathcad files: <a href=\"https://andrewmosqueda.github.io/media/files/High Side Current Measurement.mcdx\" target=\"_blank\" rel=\"noopener noreferrer\">High Side Current Sense Calculations</a></p>\n<h2>INTRODUCTION</h2>\n<p>The high side current sense circuit of DM330028 dsPIC33CH Curiosity Development board as shown below is simulated in LTSPICE and results are shown after. I also included a mathcad calculation file to quickly verify the results.</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/7/current-sense-resistors.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-resistors-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-resistors-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-resistors-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-resistors-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-resistors-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-resistors-2xl.jpg 1600w\"  alt=\"High Side Current Sense Resistors\" width=\"406\" height=\"207\"></figure><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/7/current-sense-circuit.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-circuit-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-circuit-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-circuit-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-circuit-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-circuit-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/7/responsive/current-sense-circuit-2xl.jpg 1600w\"  alt=\"Level Shifter\" width=\"743\" height=\"417\"></figure>\n<h2>LTSPICE SIMULATION CIRCUIT</h2>\n<p>The LTSPICE simulation files link is on the topmost of this page.</p>\n<figure class=\"post__image\"><br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/7/high-side-current-sense-simulation-circuit.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-circuit-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-circuit-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-circuit-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-circuit-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-circuit-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-circuit-2xl.jpg 1600w\"  alt=\"High Side Current Sense Simulation Circuit\" width=\"827\" height=\"740\"></figure>\n<h2>RESULT</h2>\n<figure class=\"post__image\"><br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/7/high-side-current-sense-simulation-result.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-result-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-result-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-result-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-result-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-result-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/7/responsive/high-side-current-sense-simulation-result-2xl.jpg 1600w\"  alt=\"High side current sense simulation result\" width=\"912\" height=\"829\"></figure>\n<h2> </h2>",
            "author": {
                "name": "Andrew Mosqueda"
            },
            "tags": [
            ],
            "date_published": "2021-09-25T08:56:51+08:00",
            "date_modified": "2021-11-28T16:49:05+08:00"
        },
        {
            "id": "https://andrewmosqueda.github.io/current-mode/",
            "url": "https://andrewmosqueda.github.io/current-mode/",
            "title": "5V to 3.3V Peak Current Mode Buck Converter in the DSPIC33CH Curiosity Development Board",
            "summary": " I will demonstrate here how to convert the previous voltage mode buck converter discussed in Voltage Mode Buck Converter to current mode. The code of the voltage mode buck converter is stored here --&gt; Voltage Mode Buck Converter - MPLAB source code. Before doing&hellip;",
            "content_html": "<p>\n<script async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2158060120252492\" crossorigin=\"anonymous\"></script>\n</p>\n<h2>INTRODUCTION</h2>\n<p>I will demonstrate here how to convert the previous voltage mode buck converter discussed in <a href=\"https://andrewmosqueda.github.io/implementing-5v-to-33v-buck-converter-in-the-dspic33ch-curiosity-development-board/\" target=\"_blank\" rel=\"noopener noreferrer\">Voltage Mode Buck Converter</a> to current mode. The code of the voltage mode buck converter is stored here --&gt; <a href=\"https://andrewmosqueda.github.io/media/files/DM330028 buck converter vmode MPLAB.zip\" target=\"_blank\" rel=\"noopener noreferrer\">Voltage Mode Buck Converter - MPLAB source code</a>.</p>\n<figure class=\"post__image\">Below is the simplified schematic of the DM330028 board's buck converter with the dsPIC33CH128MP508 I/Os. In contrast with the voltage mode converter, the IC has additional input to monitor the Power MOSFET current via RA3_ISENSEH pin. The High-Speed Analog Comparator Module is utilized to monitor this current. The duty cycle of the PWM duty cycle is also fixed to a high value (95%). Instead of the PID function changing the PWM duty cycle, its result is converted into an analog voltage by the DAC and compared to the power MOSFET current by the Comparator. So when the sense current exceeds the DAC output, the comparator output will turn high. Inside the PWM module, there is a PWM Control Input Current Limit (PCI CL) logic circuit that monitors the analog comparator output and PWM states like End-of-Cycle (EOC). The PCI CL output toggles and truncates the PWM output whenever the Analog Comparator output turns high. It then resets after detecting PWM EOC.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/close-loop-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/close-loop-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/close-loop-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/close-loop-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/close-loop-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/close-loop-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/close-loop-2-2xl.jpg 1600w\"  alt=\"Current Mode Buck Converter\" width=\"983\" height=\"578\"></figure>\n<p>Before doing the coding, it is good to understand first each circuit and modules.</p>\n<p>CURRENT SENSE CIRCUIT</p>\n<p>The power MOSFET Q6 high side current sense circuit is shown below. The voltage drop at R59 and R74 resistors is used to monitor the current at Q6. The purpose of R97 and R102 divider resistors is to make a positive bias at the dsPIC analog input pin. According to DS50002762A document, the purpose of the intentional small bias is to ensure that the current sense voltage signal is always within the internal analog comparator input sensing range and the internal DAC reachable range.</p>\n<p>I have written the derivation of the equations in mathcad (<a href=\"https://andrewmosqueda.github.io/media/files/High Side Current Measurement.mcdx\" target=\"_blank\" rel=\"noopener noreferrer\">get mathcad file here</a>) and simulate in LTSPICE (<a href=\"https://andrewmosqueda.github.io/high-side-current-sense-circuit-simulation/\" target=\"_blank\" rel=\"noopener noreferrer\">High Side Current Sense LTSPICE Simulation</a>) to easily understand the circuit. </p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/current-sense-resistors.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-resistors-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-resistors-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-resistors-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-resistors-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-resistors-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-resistors-2xl.jpg 1600w\"  alt=\"DM330028 Current Sense Resistors\" width=\"406\" height=\"207\"></figure>\n<figure class=\"post__image\"><br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/current-sense-circuit-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-circuit-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-circuit-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-circuit-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-circuit-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-circuit-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/current-sense-circuit-2-2xl.jpg 1600w\"  alt=\"High side current sense amplifier\" width=\"743\" height=\"417\"></figure>\n<p>ANALOG COMPARATOR MODULE</p>\n<figure class=\"post__image\">The RA3 pin of the dsPIC33CH IC will be configured as +input to an internal analog comparator. Below is the diagram of the internal analog comparator of the DSPIC33 IC  that is defined in DS70005280B document. The INSEL&lt;2:0&gt; register is set to S1CMP1A because this is the one connected to the RA3 pin. The PDM (Pulse Density Modulation) generates an analog voltage with level that depends on the values stored on SLPxDAT, DACxDATH and DACxDATL registers. The SLPxDAT and DACxDATL are used in slope compensation. For simplicity of this exercise, the slope compensation feature of the PDM is disabled so the output will just depend on the DACxDATH register. The PID value (compensated error value, see topic <a href=\"https://andrewmosqueda.github.io/implementing-5v-to-33v-buck-converter-in-the-dspic33ch-curiosity-development-board/\" target=\"_blank\" rel=\"noopener noreferrer\">Voltage Mode Converter</a> topic) is then stored to the DACxDATH register to dynamically adjust the comparator current threshold. DACOUT1 can be used to monitor the actual output of the PDM by an oscilloscope. The Digital Filter will also be enabled to filter unwanted output due to switching noise.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/Comparator.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-2xl.jpg 1600w\"  alt=\"DSPIC33 High Speed Comparator Module\" width=\"873\" height=\"565\"></figure>\n<p>PWM CONTROL INPUT CURRENT LIMIT (PCI CL)</p>\n<figure class=\"post__image\">The output of the internal analog comparator described above is then fed to an internal PCI logic circuit as shown below. <br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/pci.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/pci-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/pci-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/pci-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/pci-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/pci-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/pci-2xl.jpg 1600w\"  alt=\"PCI Function Block Diagram\" width=\"933\" height=\"656\"></figure>\n<p>The PCI Acceptance logic block above has three dynamic inputs; <strong>PCI Source, Qualifier </strong>and <strong>Terminator</strong>. Its ACP register is set so that it becomes Latched Mode. The Latched Mode logic is shown below.</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/PCI-acceptance-logic-latched-mode.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/PCI-acceptance-logic-latched-mode-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PCI-acceptance-logic-latched-mode-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PCI-acceptance-logic-latched-mode-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PCI-acceptance-logic-latched-mode-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PCI-acceptance-logic-latched-mode-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PCI-acceptance-logic-latched-mode-2xl.jpg 1600w\"  alt=\"PCI Acceptance Logic in Latched Mode\" width=\"269\" height=\"151\"></figure>\n<p>The input to the <strong>PCI Source</strong> is set from the analog comparator output. The input to the <strong>Qualifier </strong>is set as LEB (Leading Edge Blanking Active). The LEB is a counter which starts after PWM7H (PWM output) rises up and resets/stop when PWM7H falls down .The purpose of the LEB qualifier is to prevent unwanted turn off of the PWM during start of cycle due to unwanted transients during switching. The input to the <strong>Terminator </strong>is the AND of Auto-Terminate and EOC Event. Auto-Terminate becomes high when the analog comparator transitions from high to low. The auto-terminate ensures  that the PWM output is turned off while the current is above threshold even if the EOC Event is already reached. </p>\n<p>I have simulated the PCI CL with the comparator, PWM and the buck converter circuit in LTSPICE to have better insight about the circuit operation. See <a href=\"https://andrewmosqueda.github.io/simulation-of-the-pwm-control-input-pci-current-limit-logic-of-dspic33ch/\" target=\"_blank\" rel=\"noopener noreferrer\">PCI Current Limit Simulation.</a></p>\n<h2>PROCEDURE</h2>\n<ol>\n<li>Save the buck converter files to a different folder. </li>\n<li>Open MPLAB X IDE. After opening, close any opened projects.</li>\n<li>Open the master and slave projects of the voltage mode buck converter.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/projects.PNG\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/projects-xs.PNG 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/projects-sm.PNG 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/projects-md.PNG 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/projects-lg.PNG 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/projects-xl.PNG 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/projects-2xl.PNG 1600w\"  alt=\"MPLAB Projects pane\" width=\"190\" height=\"390\"></figure></li>\n<li>Ensure that the master project is the main project.</li>\n<li>Click the MCC button and wait the MCC to finish loading.</li>\n<li>In the Pin Manager: Grid View, set RB2 as owned by Slave Core. This pin will be used to monitor the the DAC reference for the internal analog comparator by an oscilloscope.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/Pin-Manager-RB2-DACout-slave-owned.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/Pin-Manager-RB2-DACout-slave-owned-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Pin-Manager-RB2-DACout-slave-owned-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Pin-Manager-RB2-DACout-slave-owned-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Pin-Manager-RB2-DACout-slave-owned-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Pin-Manager-RB2-DACout-slave-owned-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Pin-Manager-RB2-DACout-slave-owned-2xl.jpg 1600w\"  alt=\"MPLAB MCC Pin Manager\" width=\"612\" height=\"173\"></figure></li>\n<li>Click the Slave Core on the Project Resources pane to open the Slave Core Configuration.</li>\n<li>Click Slave Master Settings button.</li>\n<li>In the Project Resources pane, click the Generate button. Wait for the Generation Complete message to appear on the output prompt window.</li>\n<li> Click the MCC button to close the MCC application.</li>\n<li>Go back to the Projects tab on the left pane and set the slave project as Main Project.</li>\n<li>Click the MCC button and wait the MCC to finish loading.</li>\n<li>On the Master Core configuration pane, click the Load Slave Settings from Master Configuration button. Locate and select the master_config.mc3 file that was generated by the master project MCC and then after that click the open button.</li>\n<li>On the System Module pane, tick PLL Enable, select 1:100 as Feedback and FVCO/2 as AVCO Divider. These frequency settings are needed for the DAC of the Analog Comprator to function properly. <br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/system-module.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/system-module-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/system-module-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/system-module-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/system-module-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/system-module-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/system-module-2xl.jpg 1600w\"  alt=\"MPLAB MCC System Module Settings\" width=\"471\" height=\"381\"></figure></li>\n<li>On the Device Resources pane, click the + of CMP1 to move it to the Project Resources pane.</li>\n<li>On the CMP1 settings, tick Enable Comparator, Enable Digital Filter and Enable DAC Output. The digital filter is utilized to help filter out switching noises. The DAC output does not help on the operation of the comparator but is used to monitor and debug the comparator.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/Comparator-Settings.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-Settings-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-Settings-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-Settings-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-Settings-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-Settings-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/Comparator-Settings-2xl.jpg 1600w\"  alt=\"MPLAB MCC CMP1 settings\" width=\"580\" height=\"488\"></figure></li>\n<li>On the pin manager, let RA3 assigned to S1CMP1A. RA3 pin is connected to the output of the high current sense circuit of DM330038 board. Note that S1CMP1A is the one selected as the non-inverting input of the analog comparator on the above image.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/S1CMP1A.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/S1CMP1A-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/S1CMP1A-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/S1CMP1A-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/S1CMP1A-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/S1CMP1A-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/S1CMP1A-2xl.jpg 1600w\"  alt=\"MPLAB MCC Pin Manager\" width=\"408\" height=\"265\"></figure></li>\n<li>On the project resources pane, click on PWM to open the PWM configuration.</li>\n<li>Set the fixed Duty Cycle to 95%. <br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/PWM-duty-cycle.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/PWM-duty-cycle-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PWM-duty-cycle-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PWM-duty-cycle-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PWM-duty-cycle-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PWM-duty-cycle-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PWM-duty-cycle-2xl.jpg 1600w\"  alt=\"MPLAB MCC PWM duty cycle settings\" width=\"365\" height=\"90\"></figure></li>\n<li>Click on the Registers tab of the PWM settings. Wait the Registers tab to finish loading.</li>\n<li>Change the PG7CLPCIH settings to the same values with the image below. This register contains some of the settings to make the PCI becomes a current limit logic (<a href=\"https://andrewmosqueda.github.io/simulation-of-the-pwm-control-input-pci-current-limit-logic-of-dspic33ch/\" target=\"_blank\" rel=\"noopener noreferrer\">See PCI-Current Limit Logic for more details</a>). <br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/PG7CLPCIH.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIH-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIH-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIH-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIH-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIH-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIH-2xl.jpg 1600w\"  alt=\"MPLAB MCC PG7CLPCIH Settings\" width=\"306\" height=\"350\"></figure></li>\n<li>Change the PG7CLPCIL settings to the same values with the image below. This register contains the other settings to make the PCI becomes a current limit logic (<a href=\"https://andrewmosqueda.github.io/simulation-of-the-pwm-control-input-pci-current-limit-logic-of-dspic33ch/\" target=\"_blank\" rel=\"noopener noreferrer\">See PCI-Current Limit Logic for more details</a>). Also Slave Comparator 1 output is assigned as the input to the current limit logic.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/PG7CLPCIL-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIL-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIL-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIL-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIL-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIL-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7CLPCIL-2-2xl.jpg 1600w\"  alt=\"MPLAB MCC PG7CLPCIL Configuration\" width=\"357\" height=\"351\"></figure></li>\n<li>In the PG7IOCONH register, change the PENL value to disabled. This value ensures that the low side MOSFET does not turn on.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/PG7IOCONH.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/PG7IOCONH-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7IOCONH-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7IOCONH-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7IOCONH-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7IOCONH-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7IOCONH-2xl.jpg 1600w\"  alt=\"MPLAB MCC PG7IOCONH Settings\" width=\"322\" height=\"315\"></figure></li>\n<li>In the PG7LEBH register, change the PHF to enabled and PWMPCI to 7. The PHF means the PWM7H falling edge will trigger the LEB duration counter. We use a falling edge because we are driving a P MOSFET and a P MOSFET requires a negative polarity drive.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/PG7LEBH-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBH-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBH-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBH-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBH-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBH-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBH-2-2xl.jpg 1600w\"  alt=\"MPLAB MCC PG7LEBH Register\" width=\"200\" height=\"241\"></figure></li>\n<li>In Register: PG7LEBL, change the LEB value to 400. This is an arbitrary value and we can change later depending on the result.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/PG7LEBL.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBL-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBL-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBL-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBL-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBL-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/PG7LEBL-2xl.jpg 1600w\"  alt=\"MPLAB MCC PG7LEBL Configuration\" width=\"227\" height=\"88\"></figure></li>\n<li>On the Project Resources pane, click the Generate button, click Yes button on the MCC Warning confirmation and wait until Generation Complete message is displayed on the output prompt.</li>\n<li>Click the MCC button to close MCC. </li>\n<li>Open main.c file of the slave project.</li>\n<li>In the PID(void) interrupt handler function, In the last line replace PG7DC by DAC1DATH.  Basically, this means that the PID now is now fed to the Slave Comparator 1 negative input instead of directly adjusting the duty cycle of the PWM. At the end of the code append \"+260\" so that the code now becomes: DAC1DATH = n16_integrator_memory + n16_proportional + 260;. The 260 value is compensation to the offset introduced by current sense circuit.</li>\n<li>On line 62 and 63, Change the p_gain to 0.5 and i_gain to 0.1.</li>\n<li>Set the master project as the Main Project.</li>\n<li>Connect the Curiosity Development Board to the PC.</li>\n<li>Click the make and program device button.</li>\n<li>Wait until the Programming/Verify complete is prompted in the output prompt window.</li>\n</ol>\n<h2>RESULT</h2>\n<p>Oscilloscope used: ADALM2000<br>Load:100Ω (Remove power while connecting the load).</p>\n<figure class=\"post__image\">Below are the waveforms for RA3 (Orange, Current Sense Voltage) and RB2 (Purple, DAC output). These two waveforms are the input to the analog comparator. <br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/RA3vsRB2-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRB2-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRB2-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRB2-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRB2-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRB2-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRB2-2-2xl.jpg 1600w\"  alt=\"Sensed Current and DAC waveform\" width=\"1377\" height=\"768\"></figure>\n<figure class=\"post__image\">Below are the waveforms of RA3 (Orange, Current Sense Voltage) and RC14 (Purple, PWM7H output).<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/RA3vsRC14-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRC14-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRC14-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRC14-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRC14-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRC14-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsRC14-2-2xl.jpg 1600w\"  alt=\"Current Sense and PWM7H waveform\" width=\"1371\" height=\"768\"></figure>\n<figure class=\"post__image\">Below are the waveforms of RA3 (Orange, Current Sense Voltage) and VOUT (The output voltage of the converter). Output is the same with the voltage mode converter. See <a href=\"https://andrewmosqueda.github.io/implementing-5v-to-33v-buck-converter-in-the-dspic33ch-curiosity-development-board/\" target=\"_blank\" rel=\"noopener noreferrer\">Voltage mode buck converter</a><br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/6/RA3vsVout.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsVout-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsVout-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsVout-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsVout-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsVout-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/6/responsive/RA3vsVout-2xl.jpg 1600w\"  alt=\"Current Sense Voltage and Converter Output Voltage\" width=\"1372\" height=\"771\"></figure>\n<p> </p>",
            "author": {
                "name": "Andrew Mosqueda"
            },
            "tags": [
            ],
            "date_published": "2021-09-11T21:52:04+08:00",
            "date_modified": "2021-11-28T16:49:20+08:00"
        },
        {
            "id": "https://andrewmosqueda.github.io/debugging-dspic-using-uart-and-switch-interrupt/",
            "url": "https://andrewmosqueda.github.io/debugging-dspic-using-uart-and-switch-interrupt/",
            "title": "Print debugging dsPIC in Real Time using UART and switch Interrupt",
            "summary": " This is a tutorial on how to monitor the variables of a dsPIC33CH program in real time specifically on the DM330028 dsPIC33CH Curiosity Development Board using UART and switch Interrupt in MPLAB and MCC. The UART and switch Interrupts will be added to a&hellip;",
            "content_html": "<p>\n<script async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2158060120252492\" crossorigin=\"anonymous\"></script>\n</p>\n<h2>Introduction</h2>\n<p>This is a tutorial on how to monitor the variables of a dsPIC33CH program in real time specifically on the DM330028 dsPIC33CH Curiosity Development Board using UART and switch Interrupt in MPLAB and MCC. The UART and switch Interrupts will be added to a previous MPLAB project (<a href=\"https://andrewmosqueda.github.io/implementing-5v-to-33v-buck-converter-in-the-dspic33ch-curiosity-development-board/\" target=\"_blank\" rel=\"noopener noreferrer\">Buck Converter) </a>for simplicity of the explanation.</p>\n<h2>Procedure</h2>\n<ol>\n<li>Run MPLAB X IDE.</li>\n<li>Close if there are other open projects and files.</li>\n<li>Open the buck converter master and slave project.</li>\n</ol>\n<figure class=\"post__image\">MASTER CORE CONFIGURATION<br><br>Below is the UART circuit of the DM330028 dsPIC33CH Curiosity Development Board. The circuit is connected to the dsPIC33CH IC by the RC11_TXB and RC10_RXB. Since the buck operation is running in the slave core, RC11 and RC10 pins should be defined as owned by the slave core.<br><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/dsPIC33CH-Curiosity-board-UART-circuit.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-UART-circuit-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-UART-circuit-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-UART-circuit-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-UART-circuit-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-UART-circuit-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-UART-circuit-2xl.jpg 1600w\"  alt=\"DM330028 dsPIC33CH Curiosity Development Board UART circuit\" width=\"815\" height=\"443\"></figure>\n<ol>\n<li>If the master project is not bold highlighted, right click on the master project and select set as Main Project.</li>\n<li> Click the MCC button. Wait until MCC is finished loading.</li>\n<li>In the Pin Manager Pane, set RC10 and RC11 as owned by slave.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/Pin-Manager-RC10-RC11.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RC10-RC11-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RC10-RC11-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RC10-RC11-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RC10-RC11-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RC10-RC11-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RC10-RC11-2xl.jpg 1600w\"  alt=\"MPLAB MCC Pin Manager\" width=\"902\" height=\"353\"></figure><br><br>Below is the switches circuit of the DM330028 dsPIC33CH Curiosity Development Board. For this debugging, an interrupt function which contains the UART data transmission will run once everytime switch S1 is pressed. Switch S1 is connected to the dsPIC33CH IC through RE7_S1 pin. Since the buck operation is running in the slave core, RE7 pin should be defined as owned by the slave core.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/dsPIC33CH-Curiosity-board-switch-circuit.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-switch-circuit-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-switch-circuit-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-switch-circuit-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-switch-circuit-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-switch-circuit-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/dsPIC33CH-Curiosity-board-switch-circuit-2xl.jpg 1600w\"  alt=\"DM330028 dsPIC33CH Curiosity Development Board switches circuit\" width=\"363\" height=\"537\"></figure></li>\n<li>In the Pin Manager of the master project MCC, Set RE7 as owned by Slave Core.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/Pin-Manager-RE7.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RE7-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RE7-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RE7-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RE7-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RE7-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/Pin-Manager-RE7-2xl.jpg 1600w\"  alt=\"MPLAB MCC Pin Manager 2\" width=\"1328\" height=\"346\"></figure></li>\n<li>In the Project Resources Pane, click on the Slave Core (<strong>don't click x</strong>) to open the Slave Core pane.</li>\n<li>Click Save Master Settings button. This will update the master_config.mc3 file that will be uploaded later on the Slave project.</li>\n<li>In the Project Resources Pane, click Generate button to update the master core configuration files.</li>\n<li>Click the MCC button to close the master core configuration.</li>\n</ol>\n<p>SLAVE CORE CONFIGURATION</p>\n<ol>\n<li>In the Projects tab, if the slave project is not bold highlighted, right click on the slave project and select set as Main Project.</li>\n<li>Click the MCC button to open the slave core configuration. Wait until the MCC finished loading.</li>\n<li>In the Master Core Pane, click Load Slave Settings from Master Configuration button. Locate and open the master_config.mc3 that was updated in the master core configuration.</li>\n<li>In the Device Resources pane, click + of the UART1 to add UART to the Project Resources pane.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/add-UART.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/add-UART-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/add-UART-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/add-UART-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/add-UART-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/add-UART-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/add-UART-2xl.jpg 1600w\"  alt=\"MPLAB MCC Add UART\" width=\"463\" height=\"341\"></figure></li>\n<li>In the UART1 pane, tick the Redirect Printf to UART.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/UART-printf-redirect.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/UART-printf-redirect-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/UART-printf-redirect-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/UART-printf-redirect-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/UART-printf-redirect-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/UART-printf-redirect-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/UART-printf-redirect-2xl.jpg 1600w\"  alt=\"MPLAB MCC Redirect printf to UART\" width=\"627\" height=\"461\"></figure></li>\n<li>In the Pin Manager Pane, set RC10 pin for S1U1RX of UART1 and RC11 for S1U1TX.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/MPLAB-MCC-UART-pin-manager-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-UART-pin-manager-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-UART-pin-manager-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-UART-pin-manager-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-UART-pin-manager-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-UART-pin-manager-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-UART-pin-manager-2-2xl.jpg 1600w\"  alt=\"MPLAB MCC UART pin configuration\" width=\"655\" height=\"348\"></figure></li>\n<li>In the Pin Module Pane, tick Start High box for RC11. This is to ensure correct Start bit condition.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/UART-TX-start-high.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/UART-TX-start-high-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/UART-TX-start-high-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/UART-TX-start-high-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/UART-TX-start-high-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/UART-TX-start-high-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/UART-TX-start-high-2xl.jpg 1600w\"  alt=\"MPLAB MCC Pin Module configuration\" width=\"1125\" height=\"177\"></figure></li>\n<li>Go back to the Pin Manager pane, set RE7 as GPIO input.<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/RE7-input.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-input-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-input-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-input-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-input-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-input-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-input-2xl.jpg 1600w\"  alt=\"MPLAB MCC Slave Core Set RE7 as input\" width=\"881\" height=\"338\"></figure></li>\n<li>Go back to the Pin Module pane. Rename the RE7 Custom Name to RE7_S1 and change the IOC (Interrupt on Change) to negative.<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/RE7-switch-pin-module-configurationjpg.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-switch-pin-module-configurationjpg-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-switch-pin-module-configurationjpg-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-switch-pin-module-configurationjpg-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-switch-pin-module-configurationjpg-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-switch-pin-module-configurationjpg-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/RE7-switch-pin-module-configurationjpg-2xl.jpg 1600w\"  alt=\"MPLAB MCC RE7 switch input configuration\" width=\"1152\" height=\"235\"></figure></li>\n<li>In the Project Resources pane, click Generate button to update the Slave Core configuration. Click Yes to confirm.</li>\n<li>Click the MCC button to close the slave core configuration.</li>\n</ol>\n<p>SOURCE CODE</p>\n<ol>\n<li>Open the main.c file of the slave project.</li>\n<li>Append the following after the #include \"mcc_generated_files/adc1.h\" line:<br><code>#include \"mcc_generated_files/uart1.h\"</code></li>\n<li>Append the following after the void PID(void); line:<br><code>void mySw(void);</code><br>This is the declaration of the new program routine that will send UART data every time the switch on RE7 pin is pressed.</li>\n<li>I will monitor the reference, actual and error variables in this exercise. <strong>Modify </strong>the lines int16_t n16_reference; and  int16_t n16_error; to:<br><code>volatile int16_t n16_reference;<br>volatile int16_t n16_error;</code><br>Adding volatile before the declaration of a variable is a must if that variable is to be accessed by different program routines.</li>\n<li>Open the pin_manager.c file of the slave project and check if the Interrupt on Change: negative is 0 (MCC bug) as shown below. <br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/MPLAB-MCC-pin-manager-bug.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-pin-manager-bug-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-pin-manager-bug-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-pin-manager-bug-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-pin-manager-bug-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-pin-manager-bug-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB-MCC-pin-manager-bug-2xl.jpg 1600w\"  alt=\"MPLAB MCC pin manager interrupt config bug\" width=\"540\" height=\"202\"></figure><br>If it is 0, then append the following code after the SYSTEM_Initialize(); line in the main.c file:<br><code>CNEN1Ebits.CNEN1E7 = 1;</code><br>I don't know why MCC sometimes does not configure this correctly even if the IOC settings in MCC (SLAVE CORE CONFIGURATION step 9) is configured correctly.</li>\n<li>Append the following after the ADC1_SetRC1_VOUTFBInterruptHandler(PID); line:<br><code>RE7_S1_SetInterruptHandler(mySw);</code></li>\n<li>Append the following after the void PID(void) program routine:<br><code>void mySw(void)<br>{<br>    printf(\"n16_error=%d n16_reference=%d ADCBUF1=%d\\n\",\\<br>        n16_error, n16_reference, ADCBUF1);<br>}</code></li>\n<li>The modified code should now look like below:<br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/modified-code.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/modified-code-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/modified-code-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/modified-code-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/modified-code-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/modified-code-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/modified-code-2xl.jpg 1600w\"  alt=\"MPLAB UART code\" width=\"592\" height=\"922\"></figure></li>\n</ol>\n<h2>RESULT</h2>\n<ol>\n<li>Make sure J13 (VFB Gain) of the DM330028 dsPIC33CH Curiosity Development Board is shorted.</li>\n<li>Connect J20 of the Board to the PC.</li>\n<li>Set the master project as the main project.</li>\n<li>Click the program button <figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/MPLAB_program_button.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB_program_button-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB_program_button-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB_program_button-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB_program_button-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB_program_button-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/MPLAB_program_button-2xl.jpg 1600w\"  alt=\"MPLAB program button\" width=\"56\" height=\"40\"></figure>on the MPLAB toolbar.</li>\n<li>Connect J16 of the DM330028 dsPIC33CH Curiosity Development Board to the PC. This connection will be used for UART communication.</li>\n<li>Run a terminal emulator program and connect to the UART. I use the CoolTerm program.</li>\n<li>After pressing RE7 thrice, I got the result as shown below. <br><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://andrewmosqueda.github.io/media/posts/5/CoolTerm-2.jpg\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://andrewmosqueda.github.io/media/posts/5/responsive/CoolTerm-2-xs.jpg 300w ,https://andrewmosqueda.github.io/media/posts/5/responsive/CoolTerm-2-sm.jpg 480w ,https://andrewmosqueda.github.io/media/posts/5/responsive/CoolTerm-2-md.jpg 768w ,https://andrewmosqueda.github.io/media/posts/5/responsive/CoolTerm-2-lg.jpg 1024w ,https://andrewmosqueda.github.io/media/posts/5/responsive/CoolTerm-2-xl.jpg 1360w ,https://andrewmosqueda.github.io/media/posts/5/responsive/CoolTerm-2-2xl.jpg 1600w\"  alt=\"CoolTerm\" width=\"861\" height=\"388\"></figure></li>\n</ol>\n<p> </p>",
            "author": {
                "name": "Andrew Mosqueda"
            },
            "tags": [
            ],
            "date_published": "2021-08-25T21:57:12+08:00",
            "date_modified": "2021-11-28T16:49:30+08:00"
        }
    ]
}
