<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Sensorless 6-Step Control for 3-Phase Brushless Motor Tutorial - Part 3 Back EMF Detection - Andrew Mosqueda</title><meta name="description" content="Introduction This is a continuation of tutorial Potentiometer. In this tutorial, we will determine the Back EMF (BEMF) level that we need to detect. The BEMF detection is the key to determine the optimum commutation speed of the motor. Below are the map of the BEMF&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-3-protection/"><link rel="alternate" type="application/atom+xml" href="https://andrewmosqueda.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://andrewmosqueda.github.io/feed.json"><meta property="og:title" content="Sensorless 6-Step Control for 3-Phase Brushless Motor Tutorial - Part 3 Back EMF Detection"><meta property="og:site_name" content="Andrew Mosqueda - Andrew Mosqueda"><meta property="og:description" content="Introduction This is a continuation of tutorial Potentiometer. In this tutorial, we will determine the Back EMF (BEMF) level that we need to detect. The BEMF detection is the key to determine the optimum commutation speed of the motor. Below are the map of the BEMF&hellip;"><meta property="og:url" content="https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-3-protection/"><meta property="og:type" content="article"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:var(--body-font);--post-entry-font:var(--body-font);--logo-font:var(--body-font);--menu-font:var(--body-font)}</style><link rel="stylesheet" href="https://andrewmosqueda.github.io/assets/css/style.css?v=eacb492672ba3c1641d647982de266ba"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-3-protection/"},"headline":"Sensorless 6-Step Control for 3-Phase Brushless Motor Tutorial - Part 3 Back EMF Detection","datePublished":"2022-02-02T11:30","dateModified":"2022-02-03T00:09","description":"Introduction This is a continuation of tutorial Potentiometer. In this tutorial, we will determine the Back EMF (BEMF) level that we need to detect. The BEMF detection is the key to determine the optimum commutation speed of the motor. Below are the map of the BEMF&hellip;","author":{"@type":"Person","name":"Andrew Mosqueda"},"publisher":{"@type":"Organization","name":"Andrew Mosqueda"}}</script></head><body><header class="topbar" id="js-header"><div class="topbar__inner"><a class="logo" href="https://andrewmosqueda.github.io/">Andrew Mosqueda</a></div></header><div class="content"><div class="infobar"><div class="infobar__update">Last Updated: <time datetime="2022-02-03T00:10">February 3, 2022</time></div><div class="infobar__search"><form action="https://andrewmosqueda.github.io/search.html"><input type="search" name="q" placeholder="search..." aria-label="Search input"> <button type="submit" aria-label="Submit"><svg role="presentation" focusable="false" width="15px" height="14px"><use xlink:href="https://andrewmosqueda.github.io/assets/svg/svg-map.svg#search"/></svg></button></form></div></div><main class="main"><article class="post"><header class="u-header post__header"><h1>Sensorless 6-Step Control for 3-Phase Brushless Motor Tutorial - Part 3 Back EMF Detection</h1><div class="u-header__meta u-small"><img src="https://andrewmosqueda.github.io/media/website/andrew.jpg" loading="eager" class="u-header__avatar" alt="Andrew Mosqueda"><div><a href="https://andrewmosqueda.github.io/authors/andrew-mosqueda/" title="Andrew Mosqueda">Andrew Mosqueda</a> <time datetime="2022-02-02T11:30">February 2, 2022</time></div></div></header><div class="post__entry u-inner"><h2>Introduction</h2><p>This is a continuation of tutorial <a href="https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-2-potentiometer/" target="_blank" rel="noopener noreferrer">Potentiometer</a>. In this tutorial, we will determine the Back EMF (BEMF) level that we need to detect. The BEMF detection is the key to determine the optimum commutation speed of the motor. Below are the map of the BEMF signals of the X-NUCLEO-IHM07M1 board.</p><table style="border-collapse: collapse; width: 119.384%;" border="1"><tbody><tr><td style="width: 17.8774%;">Signal Name</td><td style="width: 37.6908%;">Definition</td><td style="width: 13.1193%;">Header Pin</td><td style="width: 52.4979%;">MCU Pin</td></tr><tr><td style="width: 17.8774%;">GPIO_BEMF</td><td style="width: 37.6908%;"><p>This pin should be pulled down to</p><p>enable BEMF measurement.</p></td><td style="width: 13.1193%;">C10_1</td><td style="width: 52.4979%;">PC9</td></tr><tr><td style="width: 17.8774%;">BEMF1</td><td style="width: 37.6908%;">Phase 1 Back-EMF signal</td><td style="width: 13.1193%;">C7_37</td><td style="width: 52.4979%;">PC3</td></tr><tr><td style="width: 17.8774%;">BEMF2</td><td style="width: 37.6908%;">Phase 2 Back-EMF signal</td><td style="width: 13.1193%;">C7_34</td><td style="width: 52.4979%;">PB0</td></tr><tr><td style="width: 17.8774%;">BEMF3</td><td style="width: 37.6908%;">Phase 3 Back-EMF signal</td><td style="width: 13.1193%;">C10_15</td><td style="width: 52.4979%;">PA7</td></tr></tbody></table><p>We will use BEMF3 as the BEMF detector because this pin can be connected to the positive input of an internal analog comparator of the MCU. A DAC will be used as negative input of the comparator. The DAC level will be determined using trial and error.</p><h2>Configuration</h2><ol><li>Open the Six_Step project on STM32CubeIDE. This is the project generated on the 2nd tutorial <a href="https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-2-potentiometer/" target="_blank" rel="noopener noreferrer">Potentiometer</a>. </li><li>Open the Six_Step.ioc.</li><li>On the Pinout view, click on PC9 and select GPIO_Output. This pin will be used to enable the BEMF measurement.<br><figure class="post__image"><img loading="lazy" src="https://andrewmosqueda.github.io/media/posts/14/PC9_BEMF.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-xs.jpg 300w, https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-sm.jpg 480w, https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-md.jpg 768w, https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-lg.jpg 1024w, https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-xl.jpg 1360w, https://andrewmosqueda.github.io/media/posts/14/responsive/PC9_BEMF-2xl.jpg 1600w" alt="" width="146" height="171"></figure></li><li>Click Analog-&gt;DAC. Enable the OUT1 Configuration.<br><figure class="post__image"><img loading="lazy" src="https://andrewmosqueda.github.io/media/posts/14/DAC-Setup.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-xs.jpg 300w, https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-sm.jpg 480w, https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-md.jpg 768w, https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-lg.jpg 1024w, https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-xl.jpg 1360w, https://andrewmosqueda.github.io/media/posts/14/responsive/DAC-Setup-2xl.jpg 1600w" alt="" width="462" height="265"></figure></li><li>On the Pinout view. Click PA4 and select COMP2_INM.<br><figure class="post__image"><img loading="lazy" src="https://andrewmosqueda.github.io/media/posts/14/PA4.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-xs.jpg 300w, https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-sm.jpg 480w, https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-md.jpg 768w, https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-lg.jpg 1024w, https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-xl.jpg 1360w, https://andrewmosqueda.github.io/media/posts/14/responsive/PA4-2xl.jpg 1600w" alt="" width="97" height="224"></figure></li><li>On the Pinout view. Click PA7 and select COMP2_INP.<br><figure class="post__image"><img loading="lazy" src="https://andrewmosqueda.github.io/media/posts/14/PA7_COMP2_INP-2.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-xs.jpg 300w, https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-sm.jpg 480w, https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-md.jpg 768w, https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-lg.jpg 1024w, https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-xl.jpg 1360w, https://andrewmosqueda.github.io/media/posts/14/responsive/PA7_COMP2_INP-2-2xl.jpg 1600w" alt="" width="149" height="230"></figure></li><li>Click Analog-&gt;COMP2. Select INP as positive input. Select INM as negative input. In the Parameter Settings, select Rising Edge as the Interrupt Trigger Mode.<br><figure class="post__image"><img loading="lazy" src="https://andrewmosqueda.github.io/media/posts/14/Comparator-setup-2.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-xs.jpg 300w, https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-sm.jpg 480w, https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-md.jpg 768w, https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-lg.jpg 1024w, https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-xl.jpg 1360w, https://andrewmosqueda.github.io/media/posts/14/responsive/Comparator-setup-2-2xl.jpg 1600w" alt="" width="649" height="436"></figure></li><li>On the Pinout view, click PB2 and select GPIO_Output. This pin is connected to a LED. We will turn on the LED everytime the comparator 2 interrupt is triggered and turn off everytime the TIMER 16 interrupt is triggered.<br><figure class="post__image"><img loading="lazy" src="https://andrewmosqueda.github.io/media/posts/14/PB2_LED.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-xs.jpg 300w, https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-sm.jpg 480w, https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-md.jpg 768w, https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-lg.jpg 1024w, https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-xl.jpg 1360w, https://andrewmosqueda.github.io/media/posts/14/responsive/PB2_LED-2xl.jpg 1600w" alt="" width="136" height="179"></figure></li><li>Ctrl+s to save the configuration and go to main.c</li></ol><h2>Coding</h2><ol><li>In main.c <code>/* Initialize all configured peripherals */</code>. Make sure that the <code>MX_DMA_Init();</code> is written first before <code>MX_ADC1_Init();</code>, else the DMA will not initialize properly.</li><li>After <code>#define ADC_BUF_LEN 1</code>, add <code>#define BEMF_LIMIT 1 // Volt(s)</code></li><li>Below <code>#define BEMF_LIMIT 1 // Volt(s)</code>, add <code>#define DAC1_DHR12L1 ((uint16_t)(65535*BEMF_LIMIT/3.3))</code></li><li>Before <code>/* USER CODE END 2 */</code> add the following code:<br><code>//BEMF DAC for comparator</code><br><code>  HAL_DAC_Start(&amp;hdac, DAC_CHANNEL_1);</code><br><code>  DAC1-&gt;DHR12L1 = DAC1_DHR12L1;</code><br><br><code>  //BEMF Comparator</code><br><code>  HAL_COMP_Start_IT(&amp;hcomp2);</code></li><li>Next we add the comparator interrupt handler, add the following code before  <code>/* USER CODE END 4 */</code> line :<br><code>void HAL_COMP_TriggerCallback(COMP_HandleTypeDef *hcomp)</code><br><code>{</code><br><code>    if (hcomp == &amp;hcomp2) HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, GPIO_PIN_SET); // Turn on LED</code><br><code> }</code></li><li>Then reset the LED on the TIMER16 interrupt. Add <code>HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_2); // Turn off LED</code> after the <code>TIM16-&gt;CCR1 = (adc_buf[0] * TIM16_PERIOD) &gt;&gt; 12 ;</code> line.</li></ol><h2>Determine Optimum BEMF </h2><ol><li>On the X-NUCLEO board. Set JP1 and JP2 to open position. Set JP5 and JP6 to 1Sh position.</li><li>Connect the 12V DC power supply to J1 and the motor to J2.</li><li>Connect an oscilloscope probe to C10_15. C10_15 is the BEMF3 signal.</li><li>Connect an oscilloscope probe to C10_22. C10_22 is the LED signal.</li><li>Click Run-&gt;Run menu to compile and load the program to the MCU. The orange waveform below is the BEMF of PH3. The purple waveform is the LED signal which is turned on every time BEMF rises and then turned off by TIMER16 which has a frequency of about 10kHz.<br><figure class="post__image"><img loading="lazy" src="https://andrewmosqueda.github.io/media/posts/14/BEMF-vs-LED.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-xs.jpg 300w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-sm.jpg 480w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-md.jpg 768w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-lg.jpg 1024w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-xl.jpg 1360w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-2xl.jpg 1600w" alt="" width="752" height="451"></figure></li><li>We can see that the peak voltage of the BEMF at zero torque position is 1.268V.</li><li>Now rotate counter clockwise the motor until you feel the maximum torque. It is important that the potentiometer is set to minimum position while doing this to easily rotate the motor. Below is the waveform at maximum torque that I got.<br><figure class="post__image"><img loading="lazy" src="https://andrewmosqueda.github.io/media/posts/14/BEMF-vs-LED-Max-Torque.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-xs.jpg 300w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-sm.jpg 480w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-md.jpg 768w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-lg.jpg 1024w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-xl.jpg 1360w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Max-Torque-2xl.jpg 1600w" alt="" width="709" height="452"></figure></li><li>We can see that the peak voltage of the BEMF at maximum torque position is 1.494V.</li><li>Therefore to balance torque and speed, we will use 1.381V as the BEMF level for the comparator. </li><li>Change <code>#define BEMF_LIMIT 1 // Volt(s)</code> to <code>#define BEMF_LIMIT 1.381 // Volt(s)</code> Click Run-&gt;Run. We should observe now that the LED is not turning on at zero torque: <br><figure class="post__image"><img loading="lazy" src="https://andrewmosqueda.github.io/media/posts/14/BEMF-vs-LED-DAC-26250-2.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-xs.jpg 300w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-sm.jpg 480w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-md.jpg 768w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-lg.jpg 1024w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-xl.jpg 1360w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-DAC-26250-2-2xl.jpg 1600w" alt="" width="712" height="448"></figure>But if we rotate counter clockwise the motor so that the peak voltage of the BEMF reaches 1.381V we will observe the LED begins to toggle.<br><figure class="post__image"><img loading="lazy" src="https://andrewmosqueda.github.io/media/posts/14/BEMF-vs-LED-Peak_1.381V.jpg" sizes="(max-width: 48em) 100vw, 768px" srcset="https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-xs.jpg 300w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-sm.jpg 480w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-md.jpg 768w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-lg.jpg 1024w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-xl.jpg 1360w, https://andrewmosqueda.github.io/media/posts/14/responsive/BEMF-vs-LED-Peak_1.381V-2xl.jpg 1600w" alt="" width="712" height="460"></figure></li></ol><p>Below is the video demo of the BEMF detection. Observe that the LED shines as I rotate the motor.</p><figure class="post__video"><iframe loading="lazy" width="560" height="314" src="https://www.youtube.com/embed/O2ePFm1O0r0" allowfullscreen="allowfullscreen" data-mce-fragment="1"></iframe></figure></div><aside class="post__aside"><div class="post__last-updated u-small">This article was updated on February 3, 2022</div><div class="post__share"></div></aside><footer class="post__footer"><div class="post__bio box"><img class="u-author__avatar" src="https://andrewmosqueda.github.io/media/website/andrew.jpg" loading="lazy" alt="Andrew Mosqueda"><div><h4 class="h6"><a href="https://andrewmosqueda.github.io/authors/andrew-mosqueda/" title="Andrew Mosqueda">Andrew Mosqueda</a></h4></div></div><nav class="post__nav box"><div class="post__nav__prev"><a href="https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-2-potentiometer/" class="post__nav__link" rel="prev"><div class="u-small">Previous Post<h5>Sensorless 6-step Control for 3-Phase Brushless Motor Tutorial - Part 2 Potentiometer</h5></div></a></div></nav><div class="post__related box"><h3 class="box__title">Related posts</h3><div class="post__related-wrap"><figure class="post__related-item"><figcaption><h4 class="post__related-title"><a href="https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-2-potentiometer/" class="inverse">Sensorless 6-step Control for 3-Phase Brushless Motor Tutorial - Part 2 Potentiometer</a></h4><time datetime="2022-02-01T15:56" class="u-small">February 1, 2022</time></figcaption></figure><figure class="post__related-item"><figcaption><h4 class="post__related-title"><a href="https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-1/" class="inverse">Sensorless 6-Step Control for 3-Phase Brushless Motor Tutorial - Part 1 Stator PWM</a></h4><time datetime="2022-02-01T09:18" class="u-small">February 1, 2022</time></figcaption></figure><figure class="post__related-item"><figcaption><h4 class="post__related-title"><a href="https://andrewmosqueda.github.io/ltspice-simulation-of-hysteretic-control-for-buck-converter/" class="inverse">LTspice simulation of hysteretic current control for buck converter</a></h4><time datetime="2021-11-20T22:27" class="u-small">November 20, 2021</time></figcaption></figure></div></div></footer></article><div class="comments box"><h3 class="box__title">Comments</h3><div id="disqus_thread"></div><script>var disqus_config = function () {
                    this.page.url = 'https://andrewmosqueda.github.io/sensorless-6-step-control-for-3-phase-brushless-motor-tutorial-part-3-protection/';
            		this.page.identifier = '14';
                };
            
                var disqus_loaded = false;
            
                function publiiLoadDisqus() {
                    if(disqus_loaded) {
                        return false;
                    }
            
                    var top = document.getElementById('disqus_thread').offsetTop;
            
                    if (!disqus_loaded && (window.scrollY || window.pageYOffset) + window.innerHeight > top) {
                        disqus_loaded = true;
            
                        (function () {
                            var d = document, s = d.createElement('script');
                            s.src = 'https://.disqus.com/embed.js';
                            s.setAttribute('data-timestamp', +new Date());
                            (d.head || d.body).appendChild(s);
                        })();
                    }
                }
            
                publiiLoadDisqus();
            
                window.onscroll = function() {
                    publiiLoadDisqus();
                };</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></div></main><div class="sidebar"><section class="box featured"><h3 class="box__title">Featured</h3><ul class="featured__container"><li class="featured__item"><div><a href="https://andrewmosqueda.github.io/current-mode/" class="featured__title">5V to 3.3V Peak Current Mode Buck Converter in the DSPIC33CH Curiosity Development Board</a> <time class="u-small" datetime="2021-09-11T21:52">September 11, 2021</time></div></li></ul></section><section class="box authors"><h3 class="box__title">Authors</h3><ul class="authors__cotainer"><li class="authors__item"><a href="https://andrewmosqueda.github.io/authors/andrew-mosqueda/" class="authors__image-link"><img src="https://andrewmosqueda.github.io/media/website/andrew.jpg" alt="Andrew Mosqueda"></a><div><a href="https://andrewmosqueda.github.io/authors/andrew-mosqueda/" class="authors__title">Andrew Mosqueda</a> <span class="u-small">Post: 14</span></div></li></ul></section></div><footer class="footer"><a class="footer__logo" href="https://andrewmosqueda.github.io/">Andrew Mosqueda</a><nav><ul class="footer__nav"></ul></nav><div class="footer__follow"><a href="https://www.facebook.com/andrew.mosqueda" aria-label="Facebook"><svg><use xlink:href="https://andrewmosqueda.github.io/assets/svg/svg-map.svg#facebook"/></svg> </a><a href="https://www.linkedin.com/in/alex-andrew-mosqueda-31197876/" aria-label="LinkedIn"><svg><use xlink:href="https://andrewmosqueda.github.io/assets/svg/svg-map.svg#linkedin"/></svg> </a><a href="https://www.youtube.com/channel/UCHcJ7jRLmntRZrI8h41y3Yg" aria-label="Youtube"><svg><use xlink:href="https://andrewmosqueda.github.io/assets/svg/svg-map.svg#youtube"/></svg></a></div><div class="footer__copyright"><p>andrewgs7311@gmail.com</p></div></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.navbar',
   };</script><script defer="defer" src="https://andrewmosqueda.github.io/assets/js/scripts.min.js?v=3dc768003cc6d66c9e7bf0904e71d3e8"></script><script>var images = document.querySelectorAll('img[loading]');

      for (var i = 0; i < images.length; i++) {
         if (images[i].complete) {
               images[i].classList.add('is-loaded');
         } else {
               images[i].addEventListener('load', function () {
                  this.classList.add('is-loaded');
               }, false);
         }
      }</script></body></html>